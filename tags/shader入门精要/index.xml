<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shader入门精要 on YanTree</title><link>https://yantree.github.io/tags/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/</link><description>Recent content in Shader入门精要 on YanTree</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 01 Jun 2021 20:21:12 +0800</lastBuildDate><atom:link href="https://yantree.github.io/tags/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/index.xml" rel="self" type="application/rss+xml"/><item><title>Shader入门精要-更加复杂的光照</title><link>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E6%9B%B4%E5%8A%A0%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7/</link><pubDate>Tue, 01 Jun 2021 20:21:12 +0800</pubDate><guid>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E6%9B%B4%E5%8A%A0%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7/</guid><description>技术美术——更加复杂的光照 前言 前面的学习里，场景中只有一个光源且为平行光，但在实际的项目中，我们需要处理数目更多、类型更加复杂的光源，最重要的是需要得到 阴影。这里，我们有必要知道 Unity 底层渲染引擎如何让我们在 shader 中访问它们的。
Unity 渲染路径 设置项目的渲染路径 Unity 主要有三种渲染路径：前向渲染路径、延迟渲染路径、顶点照明渲染路径，其中顶点照明渲染路径已经被淘汰，其次新的延迟渲染路径代替了原来的延迟渲染路径。
在项目中，整个项目会设置为其中一个渲染路径，默认情况下是 前向渲染路径，如果希望使用多个渲染路径，我们可以在摄像机的渲染路径设置中设置该摄像机使用的渲染路径，覆盖 Graphics 中的设置。
设置 Pass 的渲染路径 完成以上设置，我们就可以在每个 Pass 中使用标签来指定该 Pass 使用的渲染路径。这是通过设置 Pass 的 LightMode 标签实现的。例如：
Pass { Tags { &amp;#34;LightMode&amp;#34;=&amp;#34;ForwardBase&amp;#34; } } 上面代码告诉 Unity 该 Pass 使用前向渲染路径中的 ForwardBase 路径。Pass 的 LightMode 标签支持的渲染路径设置选项。
标签名 描述 Always 不管使用哪种渲染路径，该 Pass 总会被渲染，但 不会计算光照 ForwardBase 仅用于 前向渲染，该 Pass 会计算环境光、最重要的平行光、逐顶点/ SH光源和 Lightmaps ForwardAdd 仅用于 前向渲染，该 Pass 会计算额外的逐像素光源，每个 Pass 对应一个光源 Deferred 仅用于 延迟渲染，该 Pass 会渲染 G 缓冲（G-buffer） ShadowCaster 把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中 指定渲染路径的作用 借用网上一个例子，不同的渲染路径差距，如同不同的绘画方式</description></item><item><title>Shader入门精要-透明效果</title><link>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</link><pubDate>Tue, 01 Jun 2021 14:24:53 +0800</pubDate><guid>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</guid><description>技术美术——透明效果 Unity 中通常使用两种方法来实现透明：透明度测试 (AlphaTest) 和 透明度混合 (AlphaBlend) 。
透明度测试：一个片元透明度不满足条件(小于某个阈值)，那么它对应的片元就会被舍弃。被舍弃的片元将不再进行任何处理，不如写入颜色信息到 color buffer；否则，按照普通的不透明物体的处理方式来处理它，即进行 深度测试、深度写入 等。透明度测试不需要关闭深度写入，它与其他不透明物体最大的不同就是它会根据透明度来舍弃一些片元，所以它产生的效果很极端，要么完全透明，要么完全不透明，不能实现半透明效果。 透明度混合：使用当前片元的透明度作为混合因子，与已经存储在 color buffer 中的颜色值进行混合，得到新的颜色。透明度混合需要 关闭深度写入，也就是当前物体的深度信息不会被记录，但是 深度测试是开启的，也就是说当使用透明度混合渲染一个片元时，还是会比较当前物体的深度值与 depth buffer 中的深度值，如果当前物体的深度值距离摄像机更远，那么就不再进行混合操作。这一点决定了，一个不透明物体出现在一个透明物体的前面，先渲染了不透明物体，它可以正常的遮挡住透明物体。归根结底，对于透明度混合，depth buffer 是只可读的。 渲染顺序 对于透明度混合技术，我们需要关闭深度写入，但是关闭深度写入，那我们就需要小心处理透明物体的渲染顺序。
为什么需要关闭深度写入？
如果不关闭深度写入，半透明物体表面背后的面本来可以透过表面看到背后的面，由于深度测试判断半透明物体表面距离摄像机更近，就会导致表面背后的面被剔除，也就无法透过表面看到背后的面。
关闭深度写入会发生什么？
假设我们要渲染两个物体，一个是半透明物体 A，一个是不透明物体 B，A 在 b 前面 ( A 离摄像机更近)
一，先渲染 B，再渲染 A。因为不透明物体开启了深度测试和深度写入，所以 B 的数据会写进深度缓存里，当我们渲染 A 的时候，先提取深度缓存中的数据，然后和 A 进行透明度混合，显示结果正确。 二，先渲染 A，再渲染 B。由于半透明物体关闭了深度吸入，A 的深度信息不会写入深度缓存里；当渲染 B 的时候，B 的深度信息直接覆盖写入深度缓存里。实际上 B 应该再 A 的后面，但是从视角来看，B 出现在了 A 前面，显示结果错误。 又假设两个物体都是半透明物体呢？假设我们有两个物体 A 和 B，A 在 B 的前面（离摄像机更近），并且两者都是半透明物体。</description></item><item><title>Shader入门精要-基础纹理</title><link>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 31 May 2021 16:00:26 +0800</pubDate><guid>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/</guid><description>技术美术——基础纹理 常规纹理 纹理的一种使用方式就是作为常规纹理，可以理解为一张照片。在这里纹理的作用是代替 物体的漫反射系数 ，这里我们会再之前的 Blinn-Phong 高光反射 shader 的基础上实现一个基础的纹理 shader。这里可以知道常规纹理会参与 环境光 ，物体 漫反射 的计算。在基本光照模型中，由于没有相关材质贴图，所以在计算公式中
C = (c * m) * max(0 , n * l )
m 的值取为 1，不会影响到漫反射光的计算。当 m 值存在时，也就是有常规纹理的时候，光照计算中的 m 就要从常规纹理图中读取，读取方法见下面 albedo 的计算方法。
Shader &amp;#34;Unlit/MainTex0&amp;#34; { Properties { _MainTex (&amp;#34;Texture&amp;#34;, 2D) = &amp;#34;white&amp;#34; {} _Color(&amp;#34;Color&amp;#34;, Color) = (1,1,1,1) _SpecularCol(&amp;#34;Specular Col&amp;#34;, Color) = (1,1,1,1) _SpecularStrength(&amp;#34;Specular Strength&amp;#34;, Range(8.0, 256))=10 } SubShader { Tags { &amp;#34;RenderType&amp;#34;=&amp;#34;Opaque&amp;#34; &amp;#34;LightMode&amp;#34;=&amp;#34;ForwardBase&amp;#34; } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include &amp;#34;UnityCG.</description></item><item><title>Shader入门精要-简单光照模型</title><link>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E7%AE%80%E5%8D%95%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</link><pubDate>Fri, 28 May 2021 22:34:22 +0800</pubDate><guid>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E7%AE%80%E5%8D%95%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</guid><description>技术美术——基础光照模型 Lambert Lambert 光照模型的光照计算简单粗暴，是光源方向点成法线方向，其值在 [-1, 1] 之间，基本计算公式如下：
C = (c * m) * max(0 , n * l )
// 法线方向点乘光源方向 float NdotL = max(0.0,dot(normalDirection,lightDirection)); float LambertDiffuse = NdotL * SurfaceColor; float3 finalColor = LambertDiffuse * LightColor; Half Lambert Lambert 光照模型是一个简单方便的光照计算模型，但是，有一个问题存在。在光照无法照射的区域，模型外观变成了全黑，没有任何明暗的变化，使得模型背光区看起来像一个平面，失去了模型细节表现。可以通过添加环境光来得到非全黑的效果，但即使这样仍然无法解决背光面明暗一样的缺点。为了解决这个问题，有人在 Lambert 光照模型的基础上进行改良，这就是 Half Lambert 光照模型，通过乘以一个系数 a 再加上一个系数 b 的方法，将 Lambert 光照模型的值 [-1, 1] 重新映射至 [-a + b, a + b]，绝大多数情况下 a b 的值都取 0.5 ，这样 Half Lambert 光照模型的值 [0, 1]，在一定程度上改善了 Lambert 光照模型所带来的问题：</description></item></channel></rss>