<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>渲染 on YanTree</title><link>https://yantree.github.io/categories/%E6%B8%B2%E6%9F%93/</link><description>Recent content in 渲染 on YanTree</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 01 Jun 2021 20:21:12 +0800</lastBuildDate><atom:link href="https://yantree.github.io/categories/%E6%B8%B2%E6%9F%93/index.xml" rel="self" type="application/rss+xml"/><item><title>Shader入门精要-更加复杂的光照</title><link>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E6%9B%B4%E5%8A%A0%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7/</link><pubDate>Tue, 01 Jun 2021 20:21:12 +0800</pubDate><guid>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E6%9B%B4%E5%8A%A0%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7/</guid><description>技术美术——更加复杂的光照 前言 前面的学习里，场景中只有一个光源且为平行光，但在实际的项目中，我们需要处理数目更多、类型更加复杂的光源，最重要的是需要得到 阴影。这里，我们有必要知道 Unity 底层渲染引擎如何让我们在 shader 中访问它们的。
Unity 渲染路径 设置项目的渲染路径 Unity 主要有三种渲染路径：前向渲染路径、延迟渲染路径、顶点照明渲染路径，其中顶点照明渲染路径已经被淘汰，其次新的延迟渲染路径代替了原来的延迟渲染路径。
在项目中，整个项目会设置为其中一个渲染路径，默认情况下是 前向渲染路径，如果希望使用多个渲染路径，我们可以在摄像机的渲染路径设置中设置该摄像机使用的渲染路径，覆盖 Graphics 中的设置。
设置 Pass 的渲染路径 完成以上设置，我们就可以在每个 Pass 中使用标签来指定该 Pass 使用的渲染路径。这是通过设置 Pass 的 LightMode 标签实现的。例如：
Pass { Tags { &amp;#34;LightMode&amp;#34;=&amp;#34;ForwardBase&amp;#34; } } 上面代码告诉 Unity 该 Pass 使用前向渲染路径中的 ForwardBase 路径。Pass 的 LightMode 标签支持的渲染路径设置选项。
标签名 描述 Always 不管使用哪种渲染路径，该 Pass 总会被渲染，但 不会计算光照 ForwardBase 仅用于 前向渲染，该 Pass 会计算环境光、最重要的平行光、逐顶点/ SH光源和 Lightmaps ForwardAdd 仅用于 前向渲染，该 Pass 会计算额外的逐像素光源，每个 Pass 对应一个光源 Deferred 仅用于 延迟渲染，该 Pass 会渲染 G 缓冲（G-buffer） ShadowCaster 把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中 指定渲染路径的作用 借用网上一个例子，不同的渲染路径差距，如同不同的绘画方式</description></item><item><title>Shader入门精要-透明效果</title><link>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</link><pubDate>Tue, 01 Jun 2021 14:24:53 +0800</pubDate><guid>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</guid><description>技术美术——透明效果 Unity 中通常使用两种方法来实现透明：透明度测试 (AlphaTest) 和 透明度混合 (AlphaBlend) 。
透明度测试：一个片元透明度不满足条件(小于某个阈值)，那么它对应的片元就会被舍弃。被舍弃的片元将不再进行任何处理，不如写入颜色信息到 color buffer；否则，按照普通的不透明物体的处理方式来处理它，即进行 深度测试、深度写入 等。透明度测试不需要关闭深度写入，它与其他不透明物体最大的不同就是它会根据透明度来舍弃一些片元，所以它产生的效果很极端，要么完全透明，要么完全不透明，不能实现半透明效果。 透明度混合：使用当前片元的透明度作为混合因子，与已经存储在 color buffer 中的颜色值进行混合，得到新的颜色。透明度混合需要 关闭深度写入，也就是当前物体的深度信息不会被记录，但是 深度测试是开启的，也就是说当使用透明度混合渲染一个片元时，还是会比较当前物体的深度值与 depth buffer 中的深度值，如果当前物体的深度值距离摄像机更远，那么就不再进行混合操作。这一点决定了，一个不透明物体出现在一个透明物体的前面，先渲染了不透明物体，它可以正常的遮挡住透明物体。归根结底，对于透明度混合，depth buffer 是只可读的。 渲染顺序 对于透明度混合技术，我们需要关闭深度写入，但是关闭深度写入，那我们就需要小心处理透明物体的渲染顺序。
为什么需要关闭深度写入？
如果不关闭深度写入，半透明物体表面背后的面本来可以透过表面看到背后的面，由于深度测试判断半透明物体表面距离摄像机更近，就会导致表面背后的面被剔除，也就无法透过表面看到背后的面。
关闭深度写入会发生什么？
假设我们要渲染两个物体，一个是半透明物体 A，一个是不透明物体 B，A 在 b 前面 ( A 离摄像机更近)
一，先渲染 B，再渲染 A。因为不透明物体开启了深度测试和深度写入，所以 B 的数据会写进深度缓存里，当我们渲染 A 的时候，先提取深度缓存中的数据，然后和 A 进行透明度混合，显示结果正确。 二，先渲染 A，再渲染 B。由于半透明物体关闭了深度吸入，A 的深度信息不会写入深度缓存里；当渲染 B 的时候，B 的深度信息直接覆盖写入深度缓存里。实际上 B 应该再 A 的后面，但是从视角来看，B 出现在了 A 前面，显示结果错误。 又假设两个物体都是半透明物体呢？假设我们有两个物体 A 和 B，A 在 B 的前面（离摄像机更近），并且两者都是半透明物体。</description></item><item><title>Shader入门精要-基础纹理</title><link>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/</link><pubDate>Mon, 31 May 2021 16:00:26 +0800</pubDate><guid>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/</guid><description>技术美术——基础纹理 常规纹理 纹理的一种使用方式就是作为常规纹理，可以理解为一张照片。在这里纹理的作用是代替 物体的漫反射系数 ，这里我们会再之前的 Blinn-Phong 高光反射 shader 的基础上实现一个基础的纹理 shader。这里可以知道常规纹理会参与 环境光 ，物体 漫反射 的计算。在基本光照模型中，由于没有相关材质贴图，所以在计算公式中
C = (c * m) * max(0 , n * l )
m 的值取为 1，不会影响到漫反射光的计算。当 m 值存在时，也就是有常规纹理的时候，光照计算中的 m 就要从常规纹理图中读取，读取方法见下面 albedo 的计算方法。
Shader &amp;#34;Unlit/MainTex0&amp;#34; { Properties { _MainTex (&amp;#34;Texture&amp;#34;, 2D) = &amp;#34;white&amp;#34; {} _Color(&amp;#34;Color&amp;#34;, Color) = (1,1,1,1) _SpecularCol(&amp;#34;Specular Col&amp;#34;, Color) = (1,1,1,1) _SpecularStrength(&amp;#34;Specular Strength&amp;#34;, Range(8.0, 256))=10 } SubShader { Tags { &amp;#34;RenderType&amp;#34;=&amp;#34;Opaque&amp;#34; &amp;#34;LightMode&amp;#34;=&amp;#34;ForwardBase&amp;#34; } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include &amp;#34;UnityCG.</description></item><item><title>Shader入门精要-简单光照模型</title><link>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E7%AE%80%E5%8D%95%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</link><pubDate>Fri, 28 May 2021 22:34:22 +0800</pubDate><guid>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E7%AE%80%E5%8D%95%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</guid><description>技术美术——基础光照模型 Lambert Lambert 光照模型的光照计算简单粗暴，是光源方向点成法线方向，其值在 [-1, 1] 之间，基本计算公式如下：
C = (c * m) * max(0 , n * l )
// 法线方向点乘光源方向 float NdotL = max(0.0,dot(normalDirection,lightDirection)); float LambertDiffuse = NdotL * SurfaceColor; float3 finalColor = LambertDiffuse * LightColor; Half Lambert Lambert 光照模型是一个简单方便的光照计算模型，但是，有一个问题存在。在光照无法照射的区域，模型外观变成了全黑，没有任何明暗的变化，使得模型背光区看起来像一个平面，失去了模型细节表现。可以通过添加环境光来得到非全黑的效果，但即使这样仍然无法解决背光面明暗一样的缺点。为了解决这个问题，有人在 Lambert 光照模型的基础上进行改良，这就是 Half Lambert 光照模型，通过乘以一个系数 a 再加上一个系数 b 的方法，将 Lambert 光照模型的值 [-1, 1] 重新映射至 [-a + b, a + b]，绝大多数情况下 a b 的值都取 0.5 ，这样 Half Lambert 光照模型的值 [0, 1]，在一定程度上改善了 Lambert 光照模型所带来的问题：</description></item><item><title>Shader入门精要-渲染流水线</title><link>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</link><pubDate>Sun, 23 May 2021 22:20:04 +0800</pubDate><guid>https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</guid><description>技术美术——渲染流水线 应用阶段(CPU) 将场景数据加载到显存
设置渲染状态
这一步可配置的有 渲染状态，类似如下设置
Tags { &amp;#34;RenderType&amp;#34;=&amp;#34;Transparent&amp;#34; &amp;#34;Queue&amp;#34;=&amp;#34;Transparent&amp;#34; &amp;#34;IngoreProjector&amp;#34;=&amp;#34;True&amp;#34; Cull Front // 剔除正面 ZWrite off // 关闭深度写入 Blend SrcAlpha OneMinusSrcAlpha // 混合方式 调用 DrawCall
输出： 几何体数据（顶点坐标、法向量、 纹理坐标、纹理等）通过数据总线传送到图形硬件（时间瓶颈）。
几何阶段(GPU) 输入： 上个阶段的输出。
顶点着色器
根据应用阶段传进来的顶点位置做坐标变换（MVP变换矩阵）和逐顶点光照。
曲面细分着色器、几何着色器
裁剪、屏幕映射
用透视变换矩阵把顶点从视锥体变换到裁剪空间的 CVV 中，这一步叫 投影 ； CVV 中进行图元裁剪，这一步叫 裁剪；将前述过程得到的坐标映射到 屏幕空间坐标系 上，这一步叫屏幕映射。
顶点着色器
在顶点着色器中，我们经常要进行的操作是坐标空间的转换，根据光照计算的需要，我们可能会将顶点位置、法线、切线转到切线空间或者世界空间。
结果： 得到经过变换与投影之后的顶点坐标、颜色、以及纹理坐标。
顶点着色器中计算光照叫逐顶点光照，还有一种实在片元着色器中计算光照叫逐像素光照。
光栅化阶段(GPU) 输入： 上个阶段的输出</description></item><item><title>PBR基础理论</title><link>https://yantree.github.io/p/pbr%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</link><pubDate>Fri, 27 Nov 2020 09:59:25 +0800</pubDate><guid>https://yantree.github.io/p/pbr%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</guid><description>技美——PBR 基础理论 PBR 全称 Physically Based Rendering，这是一个全新的，效果出众的光照模型，是近年来实时渲染领域的趋势。
Diffusion &amp;amp; Reflection Diffusion 和 Reflection 也被叫做 “diffuse” “specular”，分别描述了物体表面和光的最基本的相互作用。绿色箭头部分的光是 specular，产生完美的反射现象，这种行为跟一个球碰撞到地面发生弹射的行为一样。红色箭头部分的光是 diffuse，会进入物体内部，这部分光要不被物体吸收（通常转化为热能），要不在物体内部散射，其中一部分会从物体表面散射出来而被重新看到。这种现象称为 “漫反射” 或更复杂一点的 “次表面散射”。
漫反射
吸收或散射根据物体表面颜色不同而不同（比如，如果物体表面呈现蓝色，表示的是物体表面吸收蓝色以外所有的光，散射出蓝色波长的光）。通常散射方向具有相当的随机性，我们可以认为散射的方向是任何方向。通常着色程序用一个颜色变量称为 “albedo” 或 “diffuse color” 来近似描述物体表面散射颜色。
1. 不会进入物体部分的光经物体表面反射会形成高光区域 “specular”，依光源颜色决定，一般为白色。
2. 进入物体部分的光会进一步在物体内部发生发射现象，出射方向是随机的，出射光 “diffuse color”，依物体属性决定
Translucency &amp;amp; Transparency 某些材质的漫反射要复杂一些——比如那些具有很长散射距离的材质：皮肤、蜡等的散射，通常一个简单的颜色变量是不够的，着色系统还需要考虑这些被照射物体的形状和厚度，如果物体足够薄，可以看到光从其背后散射出来，物体呈现半透明状；如果漫反射非常的小——比如玻璃，几乎没法注意到散射现象，光线完整的从物体的一边穿透到另一边，物体呈现全透明状。不同物体的次表面散射不尽相同，通常需要专门的“次表面散射”着色模型去模拟它。
当物体漫反射非常的小，diffusion 会穿过物体，呈透明状
Energy Conservation 根据上面的描述我们得到一个结论：漫反射和镜面反射是互斥的。这是因为被物体散射的光线必须进入物体表面（那它就不能被镜面反射了）。这个结论符合“能量守恒”，也就是说离开表面的光不可能比原始的入射光要亮。着色系统很容易做到这一点：假设1表示100%光能，用1减去镜面反射的光，剩下的就属于漫反射部分。这意味着强烈高光的物体几乎没有漫反射现象，原因就是没有光进入到物体表面，大部分被镜面反射了。反之亦然。
能量守恒定律
能量守恒是PBR的一个重要概念。它可以保证美术合适的设置材质的反射率和albedo值，而不破坏物理规则。虽然在着色系统中强制能量守恒的物理限制并不等价于最后好看的着色效果，但起码可以使得渲染效果不至于背离物理规则太远，保证在不同光照条件下物体的光照表现一致性。
Metals 金属作为最常见导电材质，有几点特性值得被特殊提及。 首先，金属大多比绝缘体更容易发生镜面反射。导体一般的镜面反射率高达60-90%，而绝缘体一般在0-20%的范围。这种高反射率阻止了大部分光到达其内部产生散射，使得金属看起来很闪亮。 其次，导体的反射率在可见光谱中呈现多样变化，使得它们的反射光具有颜色（白光照射下）。反射光具有颜色很奇怪，但确实在我们日常的材质中出现（比如，金、铜和黄铜）。绝缘体大部分情况下不会呈现出这种效果，它们的反射光的颜色是一般跟光源颜色一致。 最后，导体通常对进入其表面的光是吸收而不是散射。这意味着理论上导体不会表现出任何的漫反射，但实际中由于金属表面氧化等原因，还是会表现出部分散射效果。根据金属的这些特性呢，PBR着色系统用“metalness”作为输入来表示材料的金属程度，而不是albedo &amp;amp; reflectivity。
Metals 属性，其反射光具有颜色
Fresnel Fresnel 现象是光照反射现象中不可或缺的部分。计算机图形学中 Fresnel 用来定义不同角度下的不同反射率——入射光方向越平行于物体表面，反射率越高。这意味着物体表面在 Fresnel 效果作用下，物体的边缘会更亮。大部分人可能已经对 Fresnel 效果已经有所了解，并且 Fresnel 效果在计算机图形中也不是新东西，然而，PBR 对 Fresnel 估算公式做了一些重要的纠正。 首先，入射光方向接近平行于物体表面时，一切光滑物体边缘表现为完美镜面反射，只要它足够光滑并且在合适的观察角度（也接近平行于物体表面）下，任何材质物体都表现为完美镜面反射。这有点违反直觉，但物理现象就是如此。 其次对 Fresnel 属性的观察发现不同材质的随入射光角度变化得到的 Fresnel 变化曲线和梯度差异并不大。对我们来讲意味着：如果我们期望渲染更加真实，美术对 Fresnel 行为的控制应该被降低，而不是被放大，或者说，没必要暴露多余的 Fresnel 参数让美术去调节。少了参数控制，就简化了美术内容生成，这是个利好。PBR 光照模型根据光泽度和反射率就可以自动去计算合适的 Fresnel 效果。</description></item></channel></rss>