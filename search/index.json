[{"content":"技术美术——基础纹理 常规纹理 纹理的一种使用方式就是作为常规纹理，可以理解为一张照片。在这里纹理的作用是代替 物体的漫反射系数 ，这里我们会再之前的 Blinn-Phong 高光反射 shader 的基础上实现一个基础的纹理 shader。这里可以知道常规纹理会参与 环境光 ，物体 漫反射 的计算。在基本光照模型中，由于没有相关材质贴图，所以在计算公式中\n C = (c * m) * max(0 , n * l )\n m 的值取为 1，不会影响到漫反射光的计算。当 m 值存在时，也就是有常规纹理的时候，光照计算中的 m 就要从常规纹理图中读取，读取方法见下面 albedo 的计算方法。\nShader \u0026#34;Unlit/MainTex0\u0026#34; { Properties { _MainTex (\u0026#34;Texture\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Color(\u0026#34;Color\u0026#34;, Color) = (1,1,1,1) _SpecularCol(\u0026#34;Specular Col\u0026#34;, Color) = (1,1,1,1) _SpecularStrength(\u0026#34;Specular Strength\u0026#34;, Range(8.0, 256))=10 } SubShader { Tags { \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; \u0026#34;LightMode\u0026#34;=\u0026#34;ForwardBase\u0026#34; } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; sampler2D _MainTex; float4 _MainTex_ST; half4 _Color; half4 _SpecularCol; float _SpecularStrength; struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float2 texcoord : TEXCOORD0; }; struct v2f { float4 posWorld : SV_POSITION; float2 uv : TEXCOORD1; float3 worldNormal : NORMAL; float3 worldPos : TEXCOORD2; }; v2f vert (appdata v) { v2f o; o.posWorld = UnityObjectToClipPos(v.vertex); // 顶点位置从模型空间转到裁剪空间 o.worldNormal = UnityObjectToWorldDir(v.normal); // 顶点法线从模型空间转到世界空间 o.worldPos = UnityObjectToWorldDir(v.vertex); // 顶点从模型空间转到世界空间 o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; // 使用纹理属性的_ST对顶点纹理坐标进行变换 return o; } fixed4 frag (v2f i) : SV_Target { half3 worldNormal = normalize(i.worldNormal); // 顶点法线方向 half3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); // 主光源放方向 half3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos); // 视角方向 half3 halfDir = normalize(viewDir + worldLightDir); // 半角方向 half3 NdotL = max(0.0, dot(worldNormal, worldLightDir)); // Lambert half3 NdotV = max(0.0, dot(worldNormal, halfDir)); // BlinnPhong half3 albedo = tex2D(_MainTex,i.uv).rgb * _Color.rgb; // 漫反射系数，从纹理采样漫反射颜色作为其值 half3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; // 环境光 // 漫反射光 = 入射光线强度 * 材质的漫反射系数 * 取值为正数(表面法线方向 · 光源方向) half3 diffuse = _LightColor0.rgb * albedo * pow(NdotL * 0.5 + 0.5, 2.0); // half lambert half3 specular = _LightColor0.rgb * _SpecularCol.rgb * pow(NdotV, _SpecularStrength); // blinn phong return fixed4(diffuse + specular + ambient, 1); } ENDCG } } } 凹凸映射 凹凸映射的作用就是使用一张纹理来修改模型表面的法线，提供更多的细节效果。主要有两种方法：\n  高度映射\n一张高度纹理来模拟表面位移，然后得到一个修改后的法线值。\n  法线映射\n一张法线纹理来直接存储表面法线。\n  通常我们将高度映射和法线映射当成一种技术，但是两者的本质是有所区别的。\n法线纹理 法线纹理中存储的是表面的法线方向，由于发现分量的取值范围在 [-1, 1] 之间，而像素的分量范围在 [0, 1] ，因此两者的转换还需要做一个映射：\n pixel = (normal + 1) / 2\n 反映射后就能得到原先的法线方向\n normal = pixel * 2 - 1\n 法线的坐标空间   模型空间的法线纹理\n模型顶点的法线定义在模型空间中，一种直接的想法就是将修改后的模型空间中的表面法线存储在一张纹理中，这种纹理被称之为 模型空间的法线纹理。\n  切线空间的法线纹理\n实际应用中，我们常用模型顶点的 切线空间 存储法线。对于模型的每个顶点，都有属于自己的切线空间，模型的顶点就是切线空间的原点，顶点的法线作切线空间的 z 轴 (n)，顶点的切线方向作 x 轴 (t)，顶点的 y 轴可由 x、z 叉乘求得，也被称为 副切线 或 副法线 (b)，这就是 切线空间的法线纹理。\n  计算方式 由于法线纹理中存储的是切线空间下的方向，因此我们通常有两种选择：\n 在切线空间下进行光照计算，需要将光照方向、视角方向变换到切线空间下。 在世界空间下进行光照计算，需要把采样得到的法线方向变换到世界空间下，再和世界空间下的光照方向和视角方向进行计算。  效率上考虑，第一种优于第二种，因为整个空间的变换过程在顶点着色器中完成。\n通用性考虑，第二种优于第一种，因为有时需要在世界空间进行一次矩阵操作。\n切线空间计算 思路：1. 在顶点着色器里将模型空间下的光源方向、视角方向转到切线空间；2. 在片元着色器里直接对法线纹理进行采样，得到切线空间下的法线数值；3. 进行光照计算。\nShader \u0026#34;Unlit/MainBumpT\u0026#34; { Properties { _MainTex (\u0026#34;MainTex\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _BumpTex(\u0026#34;BumpTex\u0026#34;,2D) = \u0026#34;white\u0026#34; {} _BumpStrength(\u0026#34;Bump Strength\u0026#34;, Float) = 1.0 _Color(\u0026#34;Color Tint\u0026#34;, Color) = (1,1,1,1) _Specular(\u0026#34;Specular Color\u0026#34;, Color) = (1,1,1,1) _SpecularStrength(\u0026#34;Specular Strength\u0026#34;, Range(8.0, 256)) = 20 } SubShader { Tags { \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; \u0026#34;LightModel\u0026#34;=\u0026#34;ForwardBase\u0026#34; } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag //#include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpTex; float4 _BumpTex_ST; half _BumpStrength; half4 _Color; half4 _Specular; half _SpecularStrength; struct appdata { float4 vertex : POSITION; float4 texcoord : TEXCOORD0; float4 tangent : TANGENT; float3 normal : NORMAL; }; struct v2f { float4 uv : TEXCOORD0; // flaot4 因为使用了两张纹理贴图，所以成 flaot4 了 float4 posWorld : SV_POSITION; float3 lightDir : TEXCOORD1; float3 viewDir : TEXCOORD2; }; v2f vert (appdata v) { v2f o; o.posWorld = UnityObjectToClipPos(v.vertex); // 顶点坐标从模型空间转到裁剪空间 o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; // MainTex 的 Tiling 和 Offset o.uv.zw = v.texcoord.xy * _BumpTex_ST.xy + _BumpTex_ST.zw; // BumpTex 的 Tiling 和 offset float3 binnormal = cross(normalize(v.normal), normalize(v.tangent.xyz)) * v.tangent.w; // 得到模型空间下的副切线(.w 是取一个方向作为切线方向) float3x3 rotation = float3x3(v.tangent.xyz, binnormal, v.normal); // 一个切线空间 (顶点切线方向作为 x,叉乘值作为 y, 顶点法线作为 z) o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)); // 模型空间下的光照方向转到切线空间 o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)); // 模型空间下的视角方向转到切线空间 return o; } fixed4 frag (v2f i) : SV_Target { half3 tangentLightDir = normalize(i.lightDir); // 归一化光照方向 half3 tangentViewDir = normalize(i.viewDir); // 归一化视角方向 half3 halfDir = normalize(tangentLightDir + tangentViewDir); // 归一化半角方向 half4 packNormal = tex2D(_BumpTex,i.uv.zw); // 对法线贴图进行采样 half3 tangentNormal; tangentNormal=UnpackNormal(packNormal); tangentNormal.xy*=_BumpStrength; // 调整法线缩放，控制凹凸强度 tangentNormal.z = sqrt(1.0 - max(0.0, dot(tangentNormal.xy, tangentNormal.xy))); half3 NdotL = max(0.0, dot(tangentNormal, tangentLightDir)); // lambert half3 RdotL = max(0.0, dot(tangentNormal, halfDir)); // blinn phong half3 albedo = tex2D(_MainTex,i.uv) * _Color.rgb; // 漫反射系数(从贴图中读取) half3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; // 环境光 half3 diffuse = _LightColor0.rgb * albedo * pow(NdotL*0.5 +0.5, 2.0); // half lambert half3 specular = _LightColor0.rgb * _Specular.rgb * pow(RdotL, _SpecularStrength); return half4(ambient + diffuse + specular, 1.0); } ENDCG } } } 世界空间计算 思路：1. 在顶点着色器里将模型空间下的顶点位置、顶点法线、顶点切线、顶点副切线转到世界空间，并创建法线从切线空间转世界空间的 矩阵，用于后面采样法线纹理将法线从切线空间转到世界空间；2. 计算世界空间下的光照方向、视角方向，对法线纹理进行采样，并且将其从切线空间转到世界空间；3. 进行光照计算。\nShader \u0026#34;Unlit/MainBumpW\u0026#34; { Properties { _MainTex (\u0026#34;MainTex\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _BumpTex(\u0026#34;BumpTex\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _BumpScale(\u0026#34;Bump Scale\u0026#34;, Float) = 1.0 _Color(\u0026#34;Color\u0026#34;, Color) = (1,1,1,1) _Specular(\u0026#34;Specular\u0026#34;, Color) = (1,1,1,1) _SpecularPower(\u0026#34;Specular Power\u0026#34;, Range(8.0, 256)) = 20 } SubShader { Tags { \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; \u0026#34;LightMode\u0026#34;= \u0026#34;ForwardBase\u0026#34;} Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpTex; float4 _BumpTex_ST; float4 _Color; float4 _Specular; float _BumpScale; float _SpecularPower; struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; }; struct v2f { float4 uv : TEXCOORD0; float4 posWorld : SV_POSITION; float4 TtoW0:TEXCOORD1; float4 TtoW1:TEXCOORD2; float4 TtoW2:TEXCOORD3; }; v2f vert (appdata v) { v2f o; o.posWorld = UnityObjectToClipPos(v.vertex); // 顶点坐标从模型空间转到裁剪空间 o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; // _MainTex 缩放平移属性 o.uv.zw = v.texcoord.xy * _BumpTex_ST.xy + _BumpTex_ST.zw; // _BumpTex 缩放平移属性 half3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; // 顶点位置从模型空间转到世界空间 half3 worldNormal = UnityObjectToWorldNormal(v.normal); // 顶点法线从模型空间转到世界空间 half3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz); // 顶点切线从模型空间转到世界空间 half3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; // 计算世界空间下的副切线 o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x); o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y); o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z); return o; } fixed4 frag (v2f i) : SV_Target { half3 worldPos = half3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w); half3 lightDir = UnityWorldSpaceLightDir(worldPos); half3 viewDir = UnityWorldSpaceViewDir(worldPos); half3 halfDir = normalize(lightDir + viewDir); half3 bump = UnpackNormal(tex2D(_BumpTex, i.uv.zw)); // 从法线贴出中读取法线信息 bump.xy*=_BumpScale; // 缩放法线贴图 bump.z = sqrt(1.0 - dot(bump.xy, bump.xy)); bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));// 切线空间转世界空间 half NdotL = max(0.0, dot(bump, lightDir)); // lambert half NdotV = max(0.0, dot(bump, halfDir)); // blinn phong half3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; // 读取漫反射系数 half3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; // 环境光 half3 diffuse = _LightColor0.rgb * albedo * pow(NdotL * 0.5 + 0.5, 2.0); half3 specular = _LightColor0.rgb * _Specular.rgb * pow(NdotV, _SpecularPower); return half4(diffuse + specular + ambient, 1.0); } ENDCG } } } 渐变纹理 如常规纹理一样，我们在渲染中使用纹理是为了定义一个物体的颜色。纹理其实可以用于存储任何表面属性，一种常见的作法就是使用纹理渐变来控制漫反射光照结果。其核心部分是纹理采样计算部分，使用了 Half Lambert 作为采样UV。\n 注意将纹理的 Wrap mode 设为 Clamp\n  渐变纹理 \nShader \u0026#34;Unlit/gradient\u0026#34; { Properties { _RampTex (\u0026#34;Ramp Texture\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Color(\u0026#34;Color Tint\u0026#34;, Color) = (1,1,1,1) _Specular(\u0026#34;Specular Color\u0026#34;, Color) = (1,1,1,1) _SpecularPower(\u0026#34;Specular Power\u0026#34;, Range(8.0, 256)) = 20 } SubShader { Tags { \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; \u0026#34;LightModel\u0026#34;=\u0026#34;ForwardBase\u0026#34; } Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; sampler2D _RampTex; float4 _RampTex_ST; float4 _Color; float4 _Specular; Float _SpecularPower; struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float2 texcoord : TEXCOORD0; }; struct v2f { float4 posWorld : SV_POSITION; float3 worldNormal : TEXCOORD1; float3 worldPos : TEXCOORD2; float2 uv : TEXCOORD0; }; v2f vert (appdata v) { v2f o; o.posWorld = UnityObjectToClipPos(v.vertex); // 顶点坐标从模型空间转到世界空间 o.worldNormal = UnityObjectToWorldNormal(v.normal); // 法线从模型空间转到世界空间 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; // 位置从模型空间转到世界空间 o.uv = v.texcoord.xy * _RampTex_ST.xy + _RampTex_ST.zw; // UV 的缩放和平移属性 return o; } fixed4 frag (v2f i) : SV_Target { half3 worldNormal = normalize(i.worldNormal); // 归一化法线方向 half3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); // 归一化主光源方向 half3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); // 归一化视角方向 half3 halfDir = normalize(worldLightDir + worldViewDir); // 归一化半角方向 half NdotL = max(0.0, dot(worldNormal, worldLightDir) * 0.5 + 0.5); // lambert half NdotV = max(0.0, dot(worldNormal, halfDir)); half3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; // 环境光 half3 diffuseColor = tex2D(_RampTex, half2(NdotL, NdotL)).rgb * _Color.rgb; // 反射颜色 = 使用渐变纹理来采样半兰伯特光照生成的纹理 half3 diffuse = _LightColor0.rgb * diffuseColor; half3 specular = _LightColor0.rgb * _Specular.rgb * pow(NdotV, _SpecularPower); return half4(ambient + diffuse + specular, 1.0); } ENDCG } } FallBack \u0026#34;Specular\u0026#34; } 遮罩纹理 遮罩纹理可以让我们更加自由的控制模型表面的性质。遮罩纹理的使用一般是：通过采样得到遮罩纹理的纹素值，然后使用其中某个（或某几个）通道的值来与某种表面属性进行相乘，这样，当该通道的值为0时，可以保护表面不受该属性的影响。这里样例使用的高光的 mask ，并且是纹理的 r 通道。\n MainBump + MainBumpMask \nShader \u0026#34;Unlit/mask\u0026#34; { Properties { _MainTex (\u0026#34;MainTex\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Color(\u0026#34;Color\u0026#34;, Color) = (1,1,1,1) _BumpTex(\u0026#34;BumpTex\u0026#34;, 2D) = \u0026#34;whire\u0026#34; {} _BumpScale(\u0026#34;BumptScale\u0026#34;,Float) = 1.0 _SpecularMask(\u0026#34;Specular Mask\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _SpecularScale(\u0026#34;Specular Scale\u0026#34;, Float) = 1.0 _Specular(\u0026#34;Specualr\u0026#34;, Color) = (1,1,1,1) _SpecularPower(\u0026#34;Specular Power\u0026#34;, Range(8.0, 256)) = 20 } SubShader { Tags { \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; \u0026#34;LightModel\u0026#34;=\u0026#34;ForwardBase\u0026#34; } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; sampler2D _MainTex; float4 _MainTex_ST; float4 _Color; sampler2D _BumpTex; float4 _BumpTex_ST; float _BumpScale; sampler2D _SpecularMask; float _SpecularScale; float4 _Specular; float _SpecularPower; struct appdata { float4 vertex : POSITION; float4 texcoord : TEXCOORD0; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct v2f { float4 posWorld : SV_POSITION; float4 uv : TEXCOORD0; float3 lightDir : TEXCOORD1; float3 viewDir : TEXCOORD2; }; v2f vert (appdata v) { v2f o; o.posWorld = UnityObjectToClipPos(v.vertex); // 顶点坐标从模型空间转世界空间 o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; // _MainTex 的缩放和平移 o.uv.zw = v.texcoord.xy * _BumpTex_ST.xy + _BumpTex_ST.zw; // _BumpTex 的缩放和平移 float3 binormal = cross(normalize(v.normal), normalize(v.tangent)) * v.tangent.w; // 副切线 float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal); // 变换矩阵 o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz; // 主光源方向从模型空间转到切线空间 o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz; // 视角方向从模型空间转到切线空间 return o; } fixed4 frag (v2f i) : SV_Target { half3 tangentLightDir = normalize(i.lightDir); // 切线空间下主光源方向 half3 tangentViewDir = normalize(i.viewDir); // 切线空间下的视角方向 half3 halfDir = normalize(tangentLightDir + tangentViewDir); // 半角方向 half3 tangentNormal = UnpackNormal(tex2D(_BumpTex, i.uv.zw)); // 从法线贴图读取法线信息 tangentNormal.xy *= _BumpScale; // 缩放法线 tangentNormal.z = sqrt(1.0 - max(0.0, dot(tangentNormal.xy, tangentNormal.xy))); // 计算法线的 z 值 half NdotL = max(0.0, dot(tangentNormal, tangentLightDir)); // lambert half NdotV = max(0.0, dot(tangentNormal, halfDir)); // blinn-phong half3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb; // 从材质贴图计算漫反射率 half3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; // 环境光 half3 diffuse = _LightColor0.rgb * albedo * (NdotL * 0.5 +0.5); // 计算漫反射光 half specularMask = tex2D(_SpecularMask, i.uv).r * _Specular.rgb; // 从高光贴图中读取高光反射值 half3 specular = _LightColor0.rgb * _Specular.rgb * specularMask * pow(NdotV, _SpecularPower); return half4(ambient + diffuse + specular, 1.0); } ENDCG } } } 拓展 ：Mask 的应用还有很大的空间，可以试着举例出来：UV 顶点动画。\n总结     漫反射系数 法线系数     无纹理 1 模型法线   常规纹理 tex2D(_MainTex,i.uv).rgb * _Color.rgb 模型法线   法线纹理 tex2D(_MainTex,i.uv) * _Color.rgb tex2D(_BumpTex,i.uv.zw)   渐变纹理 tex2D(_RampTex, half2(NdotL, NdotL)).rgb * _Color.rgb 模型法线   遮罩纹理 tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb (tex2D(_BumpTex, i.uv.zw)    ","date":"2021-05-31T16:00:26+08:00","image":"https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/topimg_hub743dc7ee0e867207b7b55e10230ffbf_426847_120x120_fill_box_smart1_2.png","permalink":"https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/","title":"Shader入门精要-基础纹理"},{"content":"技术美术——基础光照模型 Lambert Lambert 光照模型的光照计算简单粗暴，是光源方向点成法线方向，其值在 [-1, 1] 之间，基本计算公式如下：\n C = (c * m) * max(0 , n * l )\n // 法线方向点乘光源方向 float NdotL = max(0.0,dot(normalDirection,lightDirection)); float LambertDiffuse = NdotL * SurfaceColor; float3 finalColor = LambertDiffuse * LightColor; Half Lambert Lambert 光照模型是一个简单方便的光照计算模型，但是，有一个问题存在。在光照无法照射的区域，模型外观变成了全黑，没有任何明暗的变化，使得模型背光区看起来像一个平面，失去了模型细节表现。可以通过添加环境光来得到非全黑的效果，但即使这样仍然无法解决背光面明暗一样的缺点。为了解决这个问题，有人在 Lambert 光照模型的基础上进行改良，这就是 Half Lambert 光照模型，通过乘以一个系数 a 再加上一个系数 b 的方法，将 Lambert 光照模型的值 [-1, 1] 重新映射至 [-a + b, a + b]，绝大多数情况下 a b 的值都取 0.5 ，这样 Half Lambert 光照模型的值 [0, 1]，在一定程度上改善了 Lambert 光照模型所带来的问题：\n//  float NdotL = max(0.0,dot(normalDirection,lightDirection) * 0.5 + 0.5); float HalfLambertDiffuse = NdotL * SurfaceColor; float3 finalColor = HalfLambertDiffuse * LightColor; Phong Lighting 高光计算部分，基本计算公式：\n Cspecular = (Clight * M specular)Max(0, V * r)\n 需要四个参数参与计算，入射光的颜色和强度 Clight，材质的高光反射系数 Mspecular，视线方向 v 以及反射方向 r。\n// 视线方向，摄像机坐标 - 顶点坐标得到视线方向，向量从顶点指向摄像机，就是视线方向  float3 viewDirection = normalize(_WorldSpaceCameraPos.xyz - i.posWorld.xyz); // 光线反射方向，有光源方向和顶点的法线方向计算得到 float3 lightReflectDirection = reflect( -lightDirection, normalDirection ); // Lambert 光照模型 float NdotL = max(0, dot( normalDirection, lightDirection )); float RdotV = max(0, dot( lightReflectDirection, viewDirection )); // 计算具体的高光，是一个指数函数，再乘以光照强度、高光颜色 float3 specularity = pow(RdotV, _SpecularGloss/4) *_SpecularPower *_SpecularColor.rgb ; float3 lightingModel = NdotL * diffuseColor + specularity; Blinn-Phong 高光计算部分，基本公式：\n Cspecular = (Clight * M specular)Max(0, n * h)\n 不同于 Phong 模型，这里不使用视线方向 v 和反射方向 r，取而代之的是引入新的矢量 h，通过视角方向 v 和光照方向 i 相加归一化处理后得到。\n// 视线方向，摄像机坐标 - 顶点坐标得到视线方向，向量从顶点指向摄像机，就是视线方向  float3 viewDirection = normalize(_WorldSpaceCameraPos.xyz - i.posWorld.xyz); // 半角方向，根据经验取得的模型，让视线方向+光源方向作为光反射的方向 float3 halfDirection = normalize(viewDirection+lightDirection); float NdotL = max(0, dot( normalDirection, lightDirection )); float NdotV = max(0, dot( normalDirection, halfDirection )); // 计算具体的高光，是一个指数函数，再乘以光照强度、高光颜色 float3 specularity = pow(NdotV ,_SpecularGloss)*_SpecularPower *_SpecularColor.rgb ; float3 lightingModel = NdotL * diffuseColor + specularity; 总结 在实际应用中，我们还是大量使用 Half Lambert 和 Blinn-Phong 光照模型，需要注意的是，这两个模型都是 经验 模型，我们从物理的角度看，这两个模型都是不正确的，但是，在实际的渲染中，这两个模型的结果更让人满意。最后给出适用的代码，可以根据需要自行注释掉关于光照部分计算的代码来观察不同光照模型之间的区别\n 四种不同光照模型的结果 \nShader \u0026#34;URP/HalfLambertBlinnPhong\u0026#34; { Properties { _Diffuse (\u0026#34;Diffuse\u0026#34;, Color) = (1,1,1,1) _Specular(\u0026#34;Specular\u0026#34;,Color) = (1,1,1,1) _Gloss(\u0026#34;Gloss\u0026#34;,Range(1.0,200))=10 } SubShader { Tags { \u0026#34;RenderPipeline\u0026#34;=\u0026#34;UniversalRenderPipeline\u0026#34; \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; } Pass { Tags { \u0026#34;LightMode\u0026#34;=\u0026#34;UniversalForward\u0026#34;} HLSLPROGRAM // UnityCG.cginc 文件被代替，使用 HLSL 文件，这里引用文件 #include \u0026#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\u0026#34; #include \u0026#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\u0026#34; #include \u0026#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl\u0026#34; #pragma vertex vert #pragma fragment frag CBUFFER_START(UnityPerMaterial) // 兼容 SRP 批处理，将所有材质属性声明在一个 UnityPerMaterial 的 CBUFFER 块中  float4 _Diffuse; float4 _Specular; float _Gloss; CBUFFER_END struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float2 lightmapUV : TEXCOORD1; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; }; v2f vert(a2v v) { v2f o; ZERO_INITIALIZE(v2f, o); // 初始化变量 o.pos=TransformObjectToHClip(v.vertex.xyz); // 顶点坐标从模型空间转到裁剪空间 o.worldNormal = TransformObjectToWorldDir(v.normal); // 法线从模型空间转到世界空间 o.worldPos = TransformObjectToWorldDir(v.vertex.xyz); // 顶点从对象空间转到世界空间 return o; } half4 frag(v2f i):SV_Target { Light mainLight = GetMainLight(); // 获取主光源 half3 worldNormal = normalize(i.worldNormal); // 顶点法线方向归一化 half3 worldLightDir = normalize(TransformObjectToWorldDir(mainLight.direction)); // 主光源方向归一化 half3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos); // 计算视角方向并且归一化 half3 lightReflectDir = reflect( -worldLightDir, worldNormal ); // 计算 phong 模型中高光部分 half3 halfDir = normalize(worldLightDir + viewDir); // 计算半角方向且归一化 half3 NdotL = max(0.0, dot(worldNormal, worldLightDir)); // Lambert half3 RdotV = max(0.0, dot(worldNormal, lightReflectDir)); // Phong half3 NdotV = max(0.0, dot(worldNormal, halfDir)); // Blinn-Phong /// lambert + Phong //half3 diffuse = mainLight.color.rgb * _Diffuse.rgb * NdotL; //half3 specular = mainLight.color.rgb * _Specular.rgb * pow(RdotV, _Gloss); /// Lambert + Blinn-Phong //half3 diffuse = mainLight.color.rgb * _Diffuse.rgb * NdotL; //half3 specular = mainLight.color.rgb * _Specular.rgb * pow(NdotV, _Gloss); /// Half Lambert + Phong //half3 diffuse = mainLight.color.rgb * _Diffuse.rgb * pow(NdotL * 0.5 + 0.5, 2.0); //half3 specular = mainLight.color.rgb * _Specular.rgb * pow(RdotV, _Gloss); /// Half Lambert + Blinn-Phong half3 diffuse = mainLight.color.rgb * _Diffuse.rgb * pow(NdotL * 0.5 + 0.5, 2.0); half3 specular = mainLight.color.rgb * _Specular.rgb * pow(NdotV, _Gloss); // 计算环境光 half3 ambient = _GlossyEnvironmentColor; half4 col= half4(ambient + diffuse + specular, 1.0); return col; } ENDHLSL } } FallBack \u0026#34;Packages/com.unity.render-pipelines.universal/FallbackError\u0026#34; } Shader \u0026#34;SRP/HalfLambertBlinnPhong\u0026#34; { Properties { _Diffuse(\u0026#34;Diffuse Color\u0026#34;, Color) = (1,1,1,1) _SpcularColor(\u0026#34;Spcular Color\u0026#34;, Color) = (1,1,1,1) _SpcularStrength(\u0026#34;Spcular Strenght\u0026#34;, Range(0.0, 100)) = 10 } SubShader { Tags { \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; float4 _Diffuse; float4 _SpcularColor; float _SpcularStrength; struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : NORMAL; float3 worldPos : TEXCOORD0; }; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); // 顶点坐标从模型空间转到裁剪空间 o.worldNormal = UnityObjectToWorldDir(v.normal); // 将法线从模型空间转到世界空间 o.worldPos = UnityObjectToWorldDir(v.vertex); // 将顶点从模型空间转到世界空间 return o; } fixed4 frag (v2f i) : SV_Target { half3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; // 获取环境光 half3 worldLightDir=normalize(_WorldSpaceLightPos0.xyz); // 主光源的方向 half3 worldNormal = normalize(i.worldNormal); // 法线方向 half3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos); // 视角方向 half3 lightReflectDir = reflect(-worldLightDir, worldNormal); // 主光源光线反射方向 half3 halfDir = normalize(viewDir + worldLightDir); half3 NdotL = max(0.0, dot(worldNormal, worldLightDir)); // lambert half3 RdotV = max(0.0, dot(worldNormal, lightReflectDir)); // phong half3 NdotV = max(0.0, dot(worldNormal, halfDir)); // blinn phong // lambert + phong //half3 diffuse = _LightColor0.rgb * _Diffuse * NdotL; //half3 specular = _LightColor0.rgb * _SpcularColor.rgb * pow(RdotV, _SpcularStrength); // Lambert + blinn phong //half3 diffuse = _LightColor0.rgb * _Diffuse * NdotL; //half3 specular = _LightColor0.rgb * _SpcularColor.rgb * pow(NdotV, _SpcularStrength); // half lambert + phong //half3 diffuse = _LightColor0.rgb * _Diffuse * pow(NdotL * 0.5 + 0.5, 2.0); //half3 specular = _LightColor0.rgb * _SpcularColor.rgb * pow(RdotV, _SpcularStrength); // half lambert + blinn phong half3 diffuse = _LightColor0.rgb * _Diffuse * pow(NdotL * 0.5 + 0.5, 2.0); half3 specular = _LightColor0.rgb * _SpcularColor.rgb * pow(NdotV, _SpcularStrength); return half4(diffuse + specular + ambient, 1); } ENDCG } } } 相关链接 Lighting Models In Unity - Jordan Stevens \n","date":"2021-05-28T22:34:22+08:00","image":"https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E7%AE%80%E5%8D%95%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/topimg_hubb21fb6872520e85a0401e3049fab639_84088_120x120_fill_q75_h2_box_smart1.webp","permalink":"https://yantree.github.io/p/shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E7%AE%80%E5%8D%95%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/","title":"Shader入门精要-简单光照模型"},{"content":"技美——函数方法解释 [TextureName]_ST\n举例来说一个纹理贴图：_Main_ST ，其中 ST 代表的是纹理的缩放属性 (Scale) 和平移 (Translation) 的缩写。_Main_ST.xy 存储缩放值，_Main_ST.zw 存储偏移值。不知道什么是纹理的缩放和偏移，建议补一下计算机图形学，里面有详细的介绍。\nPOSITION vs SV_POSITION\nPOSITION 被用作 vertex shader 的输入，SV_POSITION 被用作 vertex shader 的输出，fragment shader 的输入。SV 是 Systems Value 的简写，SV_POSITION 用来标识经过 vertex shader 变换后的顶点坐标。\nUnityObjectToClipPos\n在unity5.6 以前是 UNITY_MATRIX_MVP，用法：\nunity 5.6 前：o.vertex = mul(UNITY_MATRIX_MVP,v.vertex);\nunity 5.6 后：o.vertex = UnityObjectToClipPos(v.vertex);\n到这里就因该明白了，UnityObjectToClipPos 是一个 MVP 变换方法。\nTRANSFORM_TEX\n将模型顶点的UV与Tiling、Offset两个变量进行运算，计算出实际显示用的顶点UV，在UnityCG.cginc中的定义如下：\n// Transforms 2D UV by scale/bias property #define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw) o.uv = TRANSFORM_TEX (v.texcoord, _MainTex);\nv 是 appdata_base 类型，v.texcoord 就是模型顶点的 uv 数据。\n_MainTex 是使用的图片；\nname##_ST 实际上就是 _MainTex_ST； name## ST.xy 就是 Tiling 的 xy 值；\nname##_ST.zw 就是 Offset 的 xy 值。\nTex2D(_MainTex, IN.uv_MainTex)\nhalf4 c = tex2D (_MainTex, IN.uv_MainTex);\ntex2D(sampler2D tex, float2 s)函数，这是CG程序中用来在一张贴图中对一个点进行采样的方法，返回一个float4。这里对 _MainTex在输入点上进行了采样，并将其颜色的rbg值赋予了输出的像素颜色，将a值赋予透明度。于是，着色器就明白了应当怎样工作：即找到贴图上 对应的uv点，直接使用颜色信息来进行着色\nScene Depth / Screen Position\nScene Depth 是除开透明模型之外的深度，Screen Position是所有模型的深度。这里如果用视线空间的 Scene Depth 减去 Screen Position(Raw Model) 的 alpha，就可以得到透明模型与不透明模型相交的边缘。\nPosterize Node\n使用该节点会生成的代码：\nvoid Unity_Posterize_float4(float4 In, float4 Steps, out float4 Out) { Out = floor(In / (1 / Steps)) * (1 / Steps); } 将连续的值以 ( 1 / Steps ) 为单位向下取整，产生以 ( 1 / Steps ) 为单位标量的值。(说人话：Steps 值越大，新生成的值越接近原来的值；Steps 值越小，新生成的值越偏离原来的值，最终结果可能只剩下两个值。举例来说：一条函数曲线在 Sterps 越小的情况下越接近一条直线。)\nEllipse Node(Fragment)\n使用该节点会生成的代码：\nvoid Unity_Ellipse_float(float2 UV, float Width, float Height, out float4 Out) { float d = length((UV * 2 - 1) / float2(Width, Height)); Out = saturate((1 - d) / fwidth(d)); } 根据输入 UV 以输入宽度和高度指定的大小生成椭圆形状。\nTwirl Node\n使用该节点会生成的代码：\nvoid Unity_Twirl_float(float2 UV, float2 Center, float Strength, float2 Offset, out float2 Out) { float2 delta = UV - Center; float angle = Strength * length(delta); float x = cos(angle) * delta.x - sin(angle) * delta.y; float y = sin(angle) * delta.x + cos(angle) * delta.y; Out = float2(x + Center.x + Offset.x, y + Center.y + Offset.y); } 将类似于黑洞的旋转扭曲效果应用于输入UV的值。 变形效果的中心参考点由输入Center定义，效果的整体强度由输入Strength的值定义。 输入偏移量可用于偏移结果的各个通道。\n","date":"2021-05-22T20:09:54+08:00","permalink":"https://yantree.github.io/p/shadercode%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%A7%A3%E9%87%8A/","title":"ShaderCode常用函数解释"},{"content":"Visual Studio \u0026amp; OpenGL 这里采用的方案与 LearnOpenGL 一样，使用 glfw 和 glad。❗ 个人使用 win10 环境。\nTable of Contents\n Visual Studio \u0026amp; OpenGL  1. 配置 Visual Studio 2. 构建开发模块 3. visual Studio 编译 GLFW 4. 下载 GLAD 5. 设置项目 6. 测试用例    1. 配置 Visual Studio 安装基本的开发包，有两个必装的包。这里我使用了英文，在语言包里，我还选择了 English 安装包。\n 安装模块 \n2. 构建开发模块 新建一个 OpenGL 文件夹\n  下载 CMake ，新电脑选择 x64 的安装包，安装 CMake。\n  下载 GLFW官网，点击下载 Source package，并解压至 OpenGL 文件夹。\n  使用 CMake 编译 GLFW。\n  当前文件目录如下：\n 项目目录 \nbuild 文件夹是我自己创建的，待会编译会用到。\n  双击 CMake-gui 程序，进行编译。\n先设置好对应文件夹，如下图所示：source code 是解压后的 glfw-3.3.2 文件目录，build binaries 是我们新建的 build 文件夹，对应关系如上图所示。\n Cmake build glfw \n  接下来点击下面的 Configure 按钮。\n Cmake 配置 \n会弹出下图右边的小弹窗，确定选择的是 Visual Studio 16 2019 平台，完成后，点击下面的 Finish 按钮。\n  真正开始编译\n上面点击完 Finish 后等一会会出现如下图左边的红色页面，此时我们点击左边的 Generate 开始编译。\n Cmake 编译 \n此时，CMake 已经完成了它的所有任务。\n    3. visual Studio 编译 GLFW 在 CMake 完成编译后，上图的右边部分，我们可以直接点击 Open Project 用 Visual Studio 打开 project ，或者双击 build 后里的 GLFW.sln 文件，打开 project 后，点击 build -\u0026gt; build solution， 完成后会在 build -\u0026gt; src -\u0026gt; Debug 里生成 glfw3.lib 文件，这是我们需要的。\n4. 下载 GLAD 点击 这里 打开 GLAD 在线服务，设置如下：\n 下载GLAD \n确保 Options 下面勾选上了 Generate a loader，最后点击页面最下面的 GENERATE，此时会打开另一个页面，我们点击下面的 glad.zip ，下载 glad。将其解压在 OpenGL 文件夹下，此时 OpenGL 文件下会多出 include、src 文件夹。\n5. 设置项目 这一步我们会重点关注两个文件夹，前面的 OpenGL 和接下来要创建的项目文件夹 Learn OpenGL 。\n打开 Visual Studio 新建一个空的 project，结果如图：\n 创建空项目 \n在 LearnOpenGL 项目里新建文件夹 OpenGL_Stuff，并创建子文件夹 includes，lib，当前 LearnOpenGL 项目目录结构\n 项目目录 \n当前的 OpenGL 目录如下：\n 项目目录 \n将 OpenGL -\u0026gt; build -\u0026gt; src -\u0026gt; Debug 里生成 glfw3.lib 文件复制到 LearnOpenGL -\u0026gt; OpenGL_Stuff -\u0026gt; lib 文件夹中，将 OpenGL -\u0026gt; glfw-3.3.2 -\u0026gt; include 里的 GLFW 文件夹复制到 LearnOpenGL -\u0026gt; OpenGL_Stuff -\u0026gt; includes 文件夹中，将 **OpenGL -\u0026gt; include ** 里的 glad，KHR 文件夹复制到 LearnOpenGL -\u0026gt; OpenGL_Stuff -\u0026gt; includes 文件夹中。完成后的 LearnOpenGL 项目目录结构：\n 项目目录 \n双击 LearnOpenGL.sln 打开项目，还要将 OpenGL -\u0026gt; src 里的 glad.c 文件添加进 Learn OpenGL 项目里。打开 Visual Studio 后，直接将 glad.c 文件拖拽至 Source Files 目录里。\n  项目目录 \n接下来就是对 Learn OpenGL 项目属性设置了，打开项目后，Project -\u0026gt; Properties 。\n左边点击 VC++ Directories\n  编辑右边的 General -\u0026gt; Include Directories，选择 includes 文件路径，点击一下右下角的 Apply 按钮；\n  编辑右边的 General -\u0026gt; Library Directories，选择 lib 文件路径，点击一下右下角的 Apply 按钮；\n Visual Studio 添加文件路径 \n  左边点击 Linker -\u0026gt; Input\n编辑右边的 Additional Dependencies，输入 opengl32.lib 按一下回车继续输入 glfw3.lib ，点击一下右下角的 Apply 按钮；\n Visual Studio 添加依赖 \n到这儿，整个配置环境就搭建好了。\n6. 测试用例 新建cpp文件并测试，下面的是测试代码\n#include \u0026lt;glad/glad.h\u0026gt;#include \u0026lt;GLFW/glfw3.h\u0026gt; #include \u0026lt;iostream\u0026gt; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow* window); // settings const unsigned int SCR_WIDTH = 800; const unsigned int SCR_HEIGHT = 600; int main() { // glfw: initialize and configure  // ------------------------------  glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); #ifdef __APPLE__  glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); #endif  // glfw window creation  // --------------------  GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \u0026#34;LearnOpenGL\u0026#34;, NULL, NULL); if (window == NULL) { std::cout \u0026lt;\u0026lt; \u0026#34;Failed to create GLFW window\u0026#34; \u0026lt;\u0026lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // glad: load all OpenGL function pointers  // ---------------------------------------  if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout \u0026lt;\u0026lt; \u0026#34;Failed to initialize GLAD\u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } // render loop  // -----------  while (!glfwWindowShouldClose(window)) { // input  // -----  processInput(window); // render  // ------  glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)  // -------------------------------------------------------------------------------  glfwSwapBuffers(window); glfwPollEvents(); } // glfw: terminate, clearing all previously allocated GLFW resources.  // ------------------------------------------------------------------  glfwTerminate(); return 0; } // process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly // --------------------------------------------------------------------------------------------------------- void processInput(GLFWwindow* window) { if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); } // glfw: whenever the window size changed (by OS or user resize) this callback function executes // --------------------------------------------------------------------------------------------- void framebuffer_size_callback(GLFWwindow* window, int width, int height) { // make sure the viewport matches the new window dimensions; note that width and  // height will be significantly larger than specified on retina displays.  glViewport(0, 0, width, height); } 如果有报错的话，很可能是上一步的 Project -\u0026gt; Properties 的属性设置被复原了，此时查看一下对应的 Include Directories ，Library Directories，Additional Dependencies 的设置，如果被复原了，再重复一遍上一步的项目属性设置的操作。完成后，再编译上面代码就能看到一个窗口了。\n  OpenGL 简单窗口 \n总结 配置过程中可能会出现的问题在第六步的最下面有提到过，这里的问题产生的原因在于项目创建之后，没有创建一份文件cpp，属性设置为 Project -\u0026gt; Property，在创建一份cpp文件后，属性设置变为 Project -\u0026gt; [project name] Property。不过，没什么大的问题，重新设置一下第5步提到的 directory 就可以了。\n","date":"2020-12-29T23:09:27+08:00","image":"https://yantree.github.io/p/visual-studio-opengl/topimg_hu2678ed699bd9406efb77dd8c989f9dae_380743_120x120_fill_box_smart1_2.png","permalink":"https://yantree.github.io/p/visual-studio-opengl/","title":"Visual Studio \u0026 OpenGL"},{"content":"技美——PBR 基础理论 PBR 全称 Physically Based Rendering，这是一个全新的，效果出众的光照模型，是近年来实时渲染领域的趋势。\nDiffusion \u0026amp; Reflection Diffusion 和 Reflection 也被叫做 “diffuse” “specular”，分别描述了物体表面和光的最基本的相互作用。绿色箭头部分的光是 specular，产生完美的反射现象，这种行为跟一个球碰撞到地面发生弹射的行为一样。红色箭头部分的光是 diffuse，会进入物体内部，这部分光要不被物体吸收（通常转化为热能），要不在物体内部散射，其中一部分会从物体表面散射出来而被重新看到。这种现象称为 “漫反射” 或更复杂一点的 “次表面散射”。\n 漫反射 \n吸收或散射根据物体表面颜色不同而不同（比如，如果物体表面呈现蓝色，表示的是物体表面吸收蓝色以外所有的光，散射出蓝色波长的光）。通常散射方向具有相当的随机性，我们可以认为散射的方向是任何方向。通常着色程序用一个颜色变量称为 “albedo” 或 “diffuse color” 来近似描述物体表面散射颜色。\n1. 不会进入物体部分的光经物体表面反射会形成高光区域 “specular”，依光源颜色决定，一般为白色。\n2. 进入物体部分的光会进一步在物体内部发生发射现象，出射方向是随机的，出射光 “diffuse color”，依物体属性决定\nTranslucency \u0026amp; Transparency 某些材质的漫反射要复杂一些——比如那些具有很长散射距离的材质：皮肤、蜡等的散射，通常一个简单的颜色变量是不够的，着色系统还需要考虑这些被照射物体的形状和厚度，如果物体足够薄，可以看到光从其背后散射出来，物体呈现半透明状；如果漫反射非常的小——比如玻璃，几乎没法注意到散射现象，光线完整的从物体的一边穿透到另一边，物体呈现全透明状。不同物体的次表面散射不尽相同，通常需要专门的“次表面散射”着色模型去模拟它。\n当物体漫反射非常的小，diffusion 会穿过物体，呈透明状\nEnergy Conservation 根据上面的描述我们得到一个结论：漫反射和镜面反射是互斥的。这是因为被物体散射的光线必须进入物体表面（那它就不能被镜面反射了）。这个结论符合“能量守恒”，也就是说离开表面的光不可能比原始的入射光要亮。着色系统很容易做到这一点：假设1表示100%光能，用1减去镜面反射的光，剩下的就属于漫反射部分。这意味着强烈高光的物体几乎没有漫反射现象，原因就是没有光进入到物体表面，大部分被镜面反射了。反之亦然。\n 能量守恒定律 \n能量守恒是PBR的一个重要概念。它可以保证美术合适的设置材质的反射率和albedo值，而不破坏物理规则。虽然在着色系统中强制能量守恒的物理限制并不等价于最后好看的着色效果，但起码可以使得渲染效果不至于背离物理规则太远，保证在不同光照条件下物体的光照表现一致性。\nMetals 金属作为最常见导电材质，有几点特性值得被特殊提及。 首先，金属大多比绝缘体更容易发生镜面反射。导体一般的镜面反射率高达60-90%，而绝缘体一般在0-20%的范围。这种高反射率阻止了大部分光到达其内部产生散射，使得金属看起来很闪亮。 其次，导体的反射率在可见光谱中呈现多样变化，使得它们的反射光具有颜色（白光照射下）。反射光具有颜色很奇怪，但确实在我们日常的材质中出现（比如，金、铜和黄铜）。绝缘体大部分情况下不会呈现出这种效果，它们的反射光的颜色是一般跟光源颜色一致。 最后，导体通常对进入其表面的光是吸收而不是散射。这意味着理论上导体不会表现出任何的漫反射，但实际中由于金属表面氧化等原因，还是会表现出部分散射效果。根据金属的这些特性呢，PBR着色系统用“metalness”作为输入来表示材料的金属程度，而不是albedo \u0026amp; reflectivity。\nMetals 属性，其反射光具有颜色\nFresnel Fresnel 现象是光照反射现象中不可或缺的部分。计算机图形学中 Fresnel 用来定义不同角度下的不同反射率——入射光方向越平行于物体表面，反射率越高。这意味着物体表面在 Fresnel 效果作用下，物体的边缘会更亮。大部分人可能已经对 Fresnel 效果已经有所了解，并且 Fresnel 效果在计算机图形中也不是新东西，然而，PBR 对 Fresnel 估算公式做了一些重要的纠正。 首先，入射光方向接近平行于物体表面时，一切光滑物体边缘表现为完美镜面反射，只要它足够光滑并且在合适的观察角度（也接近平行于物体表面）下，任何材质物体都表现为完美镜面反射。这有点违反直觉，但物理现象就是如此。 其次对 Fresnel 属性的观察发现不同材质的随入射光角度变化得到的 Fresnel 变化曲线和梯度差异并不大。对我们来讲意味着：如果我们期望渲染更加真实，美术对 Fresnel 行为的控制应该被降低，而不是被放大，或者说，没必要暴露多余的 Fresnel 参数让美术去调节。少了参数控制，就简化了美术内容生成，这是个利好。PBR 光照模型根据光泽度和反射率就可以自动去计算合适的 Fresnel 效果。\n 菲涅尔效应 \nFresnel 效果会随着物体表面的光滑度变低快速的变弱，接下来的内容会介绍到这些。\n入射光方向越平行于物体表面，反射率越高，越亮。\nMicrosurface 散射和反射都依赖物体表面的朝向。宏观上来看，物体表面朝向由物体的网格形状决定，或者是网格的法线贴图决定。渲染系统根据法线信息已经可以很好的渲染散射和反射。但是真实世界的表面在微观世界是不完美的：小坑，小裂缝和小块，这些不容易被肉眼看到的微观世界下的表面特性对散射和反射仍产生巨大影响。\n 模糊效果 \n上图中，平行的入射光线被粗糙的表面分散反射。因为光线发生碰撞的微表面的朝向各不相同，就像把球扔向凹凸不平的地面一样，球的弹射方向是不可预测的。简短的说，表面越粗糙，放射的光线越分散，呈现出“模糊”状。不过对每一个微表面进行反射估值在实时渲染计算中是不现实的，所以我们不直接描述微表面细节，而是通过一个粗糙度的概念和一个相当精确的光照模型得到接近的结果，这个通用的粗糙度叫做是 “Gloss”, “Smoothness” 或 “Roughness”。在材质中可以是一张贴图或一个固定值。材质中的微表面细节是非常重要的属性，它用来模拟真实世界中的各种微表面特征。光泽度贴图不是一个新概念，但是它在基于物理的着色中占有关键的地位，因为它对光的反射效果有决定性的影响。接下来我们将会看到。\n粗糙度，物体表面的凹凸程度\nEnergy Conservation (Again) 假设我们的着色系统已经考虑了微表面细节,反射多少入射光才是合适的是个值得研究的课题。光滑的表面会比粗糙的表面得到更加清楚的高光，这是符合能量守恒物理定律的：不同的材质反射了相同量级的入射光，但粗糙的表面反射的光线更加分散，看起来更模糊更暗，而光滑的表面反射更加集中，看起来更清晰更亮。\n 反射率 \nAll Hail Microsurface 基于上面的认识我们得到一个结论：物体微表面光泽度(粗糙度)直接影响了表面的光照表现。这意味着美术人员只用通过调整光泽贴图的形状和强度就可得到物体表面的划痕、凹痕、磨损或抛光等效果，而不额外需要高光遮罩贴图或反射率这些参数设置。\n微表面细节和反射率在物理上是相互联系的，就像之前描述的散射和反射一样，抛开它们之间的联系而单独分离的去设置它们有可能违背背后的光学物理规则。\n还有，对真实世界观察发现，材质之间的反射率的差异并不明显，比如水坑和泥巴，它们有非常相近的反射率，但泥巴非常粗糙，而水坑非常光滑，它们呈现出截然不同的反射表现。美术人员在创建这样的场景应该选择光泽度(粗糙度)而不是反射率来做为主要的材质差异设置项，见下图：\n 微表面细节 \n微表面属性对其他一些效果也有略微影响。比如，Fresnel效果在粗糙表面上会变弱，还有，大或凹微表面会“捕获”更多的光线，导致光在表面出线多次反射，从而被吸收的光量增加，亮度降低。不同的PBR系统处理这些细节的方式可能有些不同，最后呈现的结果也可能有些许不同，但总体还是遵守能量守恒的。\n总结  Reflection，反射光颜色为光源颜色。 Diffuse Color，散射光部分里，物体吸收除开 Diffuse Color 颜色之外的所有光，散射出 Diffuse Color 颜色的光。 Translucency \u0026amp; Transparency，考虑到物体的形状和厚度，如果物体足够薄，可以看到光从其背后散射出来，物体呈现半透明状；如果漫反射非常的小——比如玻璃，几乎没法注意到散射现象，光线完整的从物体的一边穿透到另一边，物体呈现全透明状。 Metals，反射光具有颜色，不受光源颜色左右，材料的金属程度。 Fresnel，入射光方向越平行于物体表面，反射率越高，越亮。 Microsurface，物体的光泽度。   原文连接：\n外文：https://marmoset.co/posts/basic-theory-of-physically-based-rendering/\n翻译：https://zhuanlan.zhihu.com/p/49564527\n ","date":"2020-11-27T09:59:25+08:00","image":"https://yantree.github.io/p/pbr%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/topimg_hu85975aebbe83c38bfa94df6e1d3760eb_64270_120x120_fill_q75_box_smart1.jpg","permalink":"https://yantree.github.io/p/pbr%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/","title":"PBR基础理论"},{"content":"Doom Emacs \u0026amp; Win10 Table of Contents\n Doom Emacs \u0026amp; Win10  准备工作 编辑系统环境变量 安装Doom All the icons    Doom Emacs，是一份成熟的 Emacs 配置文件，相较于自己一点一滴的积攒 Emacs 配置，Doom Emacs 能让你立即开始你的工作，把更多精力放在编码或者工作上而不是折腾配置文件。\n准备工作 以下方式是不通过第三方包管理器的安装配置过程，使用第三方包管理器会方便很多。\n 下载 Git 下载 Ripgrep 和 fd。确保你下载的是 Windows-gnu 版本。 下载主角 Emacs。  Git 是 .exe 文件，双击安装；解压缩 Ripgrep 和 fd，最好重命名一下文件夹分别叫 Ripgrep 和fd ，你可以把这两个文件夹放在你喜欢的位置。(后面会用到) Emacs 有 .exe 文件，可以直接安装，也有免安装版，不管使用什么方式，同上面 Ripgrep 和 fd 的使用一样，记住 Emacs 放在了哪儿。\n编辑系统环境变量   文件浏览器 -\u0026gt; 此电脑 -\u0026gt; 属性(左上角，第二个中间画 √ 的图标) -\u0026gt; 高级系统设置 -\u0026gt; 环境变量 -\u0026gt; 用户变量下面\n 新建，设置变量名为 HOME ，变量值为 C:\\Users\\USERNAME 点击 确认。 选中名为 Path 的变量，编辑 并添加 C:\\path\\to\\the\\emacs\\bin 文件路径，点击 确认。 选中名为 Path 的变量，编辑 并添加 C:\\path\\to\\the\\ripgrep 文件路径，点击 确认。 选中名为 Path 的变量，编辑 并添加 C:\\path\\to\\the\\fd 文件路径，点击 确认。 点击 确认。  所以要记住上面三个软件的安装目录，不要有遗漏的地方。\n  安装Doom  打开 git-bash.exe。 输入 cd ~，中间有个空格。 输入 git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.emacs.d。 等下载完成后输入 cd .emacs.d/bin，执行 doom install，过程中，单击y 继续。 重复上面的操作 文件浏览器 -\u0026gt; 此电脑 -\u0026gt; 属性(左上角，第二个中间画 √ 的图标) -\u0026gt; 高级系统设置 -\u0026gt; 环境变量 -\u0026gt; 用户变量下面  选中名为 Path 的变量，编辑 并添加 C:\\Users\\USERNAME\\.emacs.d\\bin 文件路径，点击 确认。 点击 确认。    现在才安装完成，可以打开 Emacs 了。\nAll the icons 默认状态下，Windows 上没法自动安装字体，但 all the icons 这款插件有依赖于一些特殊的字体，所以我们要手动安装。\n 打开 Emacs ，M-x package-install RET all-the-icons RET 确保安装了 all the icons。 M-x all-the-icons-install-fonts ，完成后，找到字体下载的位置，双击安装。  现在你就可以使用 Doom Emacs。\n Happy Hacking! \n","date":"2020-11-06T14:17:09+08:00","image":"https://yantree.github.io/p/doom-emacs/topimg_hu1fc36ca756b092af5e34a851759d7448_71281_120x120_fill_box_smart1_2.png","permalink":"https://yantree.github.io/p/doom-emacs/","title":"Doom Emacs"},{"content":"Magit  A Git Porcelain inside Emacs。Magit\n Magit 可以看作是一个嵌在 Emacs 里的一个客户端，但它同时也提供了命令行的操作（废话）。在 Emacs 里打开一个 Git 项目，M-x: magit-status 这样就启动了 magit 了，之后下面提到的操作就非常简单了。\nTable of Contents\n Magit  1. Branch 2. Stage(all) / Unstage(all) 3. Commit 4. Log 5. Push 6. Reset 总结    1. Branch b\n magit-branch \n会弹出以上菜单，和你平时看到的完全不同（毕竟是在 Emacs）。\n其中紫色对应的是 按键 后面的白色字体就是具体功能的描述了。例如：再单击 c 我们就进入了创建新分支的命令。Branch\n2. Stage(all) / Unstage(all) 这里我们可以 Stage 单个文件，也可以 Stage 全部缓冲区的文件，相反，Unstage 也是这样的。\ns S 全选 , u U 全选 小写对应是单个缓冲区文件，大写对应的是全部缓冲区文件。Stage/Unstage\n3. Commit c\n magit-commit \n再单击一次 c 就会进入编辑 commit 的界面了，根据界面提示，C-c C-c 提交 commit ，C-c C-k 取消 commit 。Commit\n 上面 \u0026lsquo;-a\u0026rsquo;, \u0026lsquo;-e\u0026rsquo;\u0026hellip;的意思也是一样的，按 - a，不同的是带 - 前缀的功能只会在当前的操作上暂时启用，而且后面灰色的注释会暂时高亮，代表着暂时启用对应的。当你再一次按 c 时，后面的注释还是灰色，代表着没开启对应的功能。\n 4. Log l\n还是弹出一个与上面类似的菜单，这里就不展示图片了。再次单击，我们就能看到当前分支的所有 commit 记录。最常用的就是这个功能了，当然里面还有很多我还没使用过的功能。但是 在这个显示 LOG 记录的页面里，我们还可以轻松的完成 RESET， REVERT 这两个常用的操作。Log\n5. Push p\n在弹出菜单后，再按一次 p，就触发了 push 。Push\n magit-push-force-lease \n❗ 当我们执行回滚操作后，要将回滚后的仓库提交到远程仓库时，执行以上 push 的方法是行不通的，无法提交到远程仓库\n先按 p，进入 push 菜单；再按 - f，暂时开启 force with lease；然后再按 p 执行 push 操作，就能提交成功！\n 想要具体了解 force with lease 与 force 之间的区别，自己百度一下就明白了。\n 6. Reset X\n magit-reset \n上面的说明够直白清楚的了，在我们一般惯性思维里，会选择 X h，这种方式——一切都回到原来的那个状态。Reset\n 先按 l l 进入 Log，选择 Reset 的点之后，再进行上面的操作。\n 总结  直接在 Github 单击下载按钮下载的仓库是没有 .git 文件夹的，也就是说这样下载下来的不是一个仓库\u0026hellip;\u0026hellip;问题很大，所以还是使用 git clone ...... 的方式更稳妥，除非你不想要 .git 文件，也就是仓库提交记录。 在本地仓库新建 dev branch 时，先 p u，目的是在远程仓库创建也新建一个 dev branch，然后再 p p，不然会报错，你还不知道怎么弄。  ","date":"2020-06-21T09:14:22+08:00","image":"https://yantree.github.io/p/emacs-magit%E6%8F%92%E4%BB%B6/topimg_huffff616dccac0c778e7c8ccddfec01fc_19763_120x120_fill_box_smart1_2.png","permalink":"https://yantree.github.io/p/emacs-magit%E6%8F%92%E4%BB%B6/","title":"Emacs Magit✨插件"},{"content":"HUGO|Github Actions|Github Pages 使用方法主要参考了这篇 文章 。在这里我只是提炼一些关键点和遇到的坑。\n1. 绑定 SSH Key 如果是两个独立的仓库的，将 Public Key 添加到 \u0026lt;YourName\u0026gt;.github.io 仓库，打开 setting 面板，找到 Deploy keys 选项，Title： Deploy Github Page（看你个人喜好）。Key： Public Key ；将 Private Key 添加到 another repository 仓库，打开 setting 面板，找到 Secrets 选项，Name： ACTIONS_DEPLOY_KEY（后面会用到）。Value： Private Key 。这里有一个坑，要复制整个 Private Key 的值作为 Value ，不然后面会报错。这是具体的issues\n2. 配置 yml name:Github Pageson:push:branches:- masterjobs:deploy:runs-on:ubuntu-18.04steps:- uses:actions/checkout@v2#with:#submodules: true # Fetch Hugo themes (true OR recursive)#fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;0.71.1\u0026#39;# extended: true- name:Buildrun:hugo- name:Deployuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}external_repository:YanTree/YanTree.github.iopublish_branch:master #推送的分支publish_dir:./public #要推送的文件夹commit_message:${{ github.event.head_commit.message }}注意调整上面 29-32 高亮行的值，ACTIONS_DEPLOY_KEY 对应的是上面 Secret 的 Name ，external_repository 改成你对应的仓库名 \u0026lt;YourName\u0026gt;/\u0026lt;YourName\u0026gt;.github.io\n反思 如果是使用 SSH 作为 Token ，在电脑重装系统或者更换电脑的情况下，我们每一次都要重新更新 Deploy keys ， Secrets 的值，对于我这种动不动就重装系统的人不太友好😁。所以我新建了一个 Personal access tokens 专门干这件事儿，目前看来是避免了上诉的痛点。本来是打算使用 GITHUB_TOKEN 的，都不要额外配置，但是这个 TOKEN 只适用于同一个仓库，这是具体的 issues，如果你是使用的同一个仓库的话，就可以使用这个功能了。\n","date":"2020-06-20T19:56:17+08:00","image":"https://yantree.github.io/p/github-actions-%E6%8E%A8%E9%80%81-github-page/topimg.svg","permalink":"https://yantree.github.io/p/github-actions-%E6%8E%A8%E9%80%81-github-page/","title":"Github Actions 推送 Github Page"},{"content":"Leaning Git and Github! 这是我自己学习使用 Git Github 时整理出的笔记，当时 Github 还没有出 官方教程，没有 论坛，现在都有了，这都是很好的学习资源，强烈推荐:+1:。这份文章列出了我学习时遇到的问题和解决方法，刚好趁这次疫情期间再整理一下，主要是将 ORG 文件转成 Markdown 文件的工作，因为 Github 对 org 文件格式并不友好，真的非常遗憾 :disappointed:！\nTable of Contents\n Leaning Git and Github!  config global user\u0026rsquo;s imformation git clone  1. 利用 Gitee 做工具人 2. 使用 cnpmjs镜像   解决git push代码到github上一直提示输入用户名及密码的问题  原因分析 解决办法   工作区的文件操作  撤销操作 添加和删除操作 移除版本控制   branch操作  创建操作 查看并切换 合并(merge) 删除分支(delete)   设置远程仓库 push an existing repository from the command line create a new repository on the command line 回滚 pull requests and merge  pull requests merge   总结    config global user\u0026rsquo;s imformation git config --global user.name \u0026#34;YourName\u0026#34; git config --global user.email \u0026#34;YourEmail@example.com\u0026#34; git clone 因为一些原因，国内克隆 GitHub 仓库的下载速度非常非常慢，这里提供两种解决办法。\n1. 利用 Gitee 做工具人 注册一个 Gitee 账号。点击右上角的 ➕ ，选择 从 Github/GitLab 导入仓库，导入完成后使用 Github 同样的方式克隆仓库就行了。git clone git@gitee.com:[YourName]/[YourRepository]  ，将 github 换成 gitee。这个方法有点繁琐，不过效果好。\n2. 使用 cnpmjs镜像 这个方法非常简单，只要修改地址后面的 github.com 为 github.com.cnpmjs.org\ngit clone https://github.com/[YourName]/[YourRepository] # 使用cnpmjs git clone https://github.com.cnpmjs.org/[YourName]/[YourRepository] 解决git push代码到github上一直提示输入用户名及密码的问题 原因分析 出现这种情况的原因是我们使用了 http 的方式 clone 代码到本地,相应的,也是使用 http 的方式将代码 push 到服务器.\n解决办法 解决办法很简单,将http方式改为ssh方式即可. 步骤：\n 先查看当前方式  git remote -v 把http方式改为ssh方式。先移除旧的http的origin  git remote rm origin 再添加新的ssh方式的origin  git remote add origin git@github.com:userName/repositoryName.git 改动完之后直接执行git push是无法推送代码的，需要设置一下上游要跟踪的分支,与此同时会自动执行一次git push命令,此时已经不用要求输入用户名及密码啦！​⚠​ 注意自己当前的分支，下面是推送到 master 分支。  git push --set-upstream origin master 工作区的文件操作 撤销操作 假设有文件 test01.txt和/test/test02.txt\n代码分别是：\ngit checkout -- test01.txt git checkout -- /test/test02.txt 添加和删除操作 添加\ngit add filename 删除\ngit rm filename 移除版本控制 git rm -r --cached file 在 .gitignore 中添加要移除的文件，最后：\ngit commit -m \u0026#39;modified .gitignore\u0026#39; branch操作 创建操作 我们创建dev分支，然后切换到dev分支\ngit checkout -b dev :exclamation: 解释上一条命令。\ngit checkout命令加上 -b 参数表示创建并切换，相当于以下两条命令：\ngit branch devgit checkout dev 查看并切换  查看 紧接着上面创建 dev 分支后，继续讲。带 * 号的就是当前分支。  git branch* dev master 切换至 master 分支  git checkout {master} 合并(merge) master ➡ dev\ngit merge dev 删除分支(delete) 删除 dev 分支\ngit branch -d devDeleted branch dev (was b17d20e). 设置远程仓库  创建SSH key  打开Shell，输入以下代码\nssh-keygen -t rsa -C \u0026#34;youremail@example.com\u0026#34; 之后不用管直接按两次 Enter 就创建完毕了。\n添加SSH密匙 创建完毕后用户目录下应该有个 .ssh 的文件夹。（:exclamation: 没有的话，可能是你没有显示隐藏文件）复制 id_rsa.pub 文件里的所有内容。  登录自己的 Github 账户，点击右上角头像图标。 点击 Settings 。 找到并点击新页面下的 SSH and GPG keys 。 右边的页面刷新后，点击 SSH keys 右边的 New SSH key 。 自己起一个 title，例如当前的设备 win10-work，在 Key 这里粘贴刚刚从 id_rsa.pub 文件里复制的所有内容。 最后点击 Add SSH key 大功告成。:tada:    push an existing repository from the command line git remote add origin git@github.com:userName/repositoryName.gitgit push -u origin master create a new repository on the command line echo \u0026#34;# .emacs.d(your repository name)\u0026#34; \u0026gt;\u0026gt; README.mdgit initgit add README.mdgit commit -m \u0026#34;first commit\u0026#34;git remote add origin git@github.com:userName/repositoryName.gitgit push -u origin master 回滚  查看当前版本库的状态  git log or\ngit log --pretty=oneline 回滚到上一次提交  git reset --hard HEAD^ or\ngit reset --hard [commit id(前五到六位数就够了)] ⚠ 注意\n 参数 hard 的作用 HEAD^^=HEAD~2 意思就是回滚到前两次提交的状态  如果想恢复到新版本  \u0026gt; git reflog 查看commit记录 根据commit id 进行回滚(见步骤2)    pull requests and merge pull requests 就是向一个分支提出合并请求，合并前弄清楚谁是被合并的分支\nmerge 在提出一个pull requests 请求后，我们可以合并分支，也可以不合并，这就是这一步要做的事情。在合并时也可能出现问题，到时候自行Google，目前的经历的一个问题，是通过删除或保留一些“问题”文件解决的。\n总结 除了一直提示输入用户名及密码的问题外，其他所有的问题都是比较容易解决的。当然我现在并没有使用官网命令行的 Git ，在接触了 Emacs 后，有一个叫 Magit 的 Emacs 杀手锏，类似于图形化界面的操作，我基本上就没用过命令行了。哈哈，having a nice day！\n","date":"2020-04-15T18:30:30+08:00","image":"https://yantree.github.io/p/git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88%E6%9C%AC%E5%AD%A6%E4%B9%A0/topimg_hu8e2cda63a051da7ad17a0ebf4ac926f6_19259_120x120_fill_box_smart1_2.png","permalink":"https://yantree.github.io/p/git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88%E6%9C%AC%E5%AD%A6%E4%B9%A0/","title":"Git 命令行版本学习"}]