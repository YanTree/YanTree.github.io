#+STARTUP: indent
* leaning structure of programming and ....
** first chapter
** second chapter
#+BEGIN_SRC cl
;;1.2.2
;;count-change
(defun cc (amount kinds-of-coins)
	   (cond ((= amount 0) 1)
		 ((or (< amount 0) (= kinds-of-coins 0)) 0)
		 (t (+ (cc amount
			   (- kinds-of-coins 1))
		       (cc (- amount
			      (first-denomination kinds-of-coins))
			   kinds-of-coins)))))

(defun first-denomination (kinds-of-coins)
	   (cond ((= kinds-of-coins 1) 1)
		 ((= kinds-of-coins 2) 5)
		 ((= kinds-of-coins 3) 10)
		 ((= kinds-of-coins 4) 25)
		 ((= kinds-of-coins 5) 50)))

(defun count-change (amount)
	   (cc amount 5))
#+END_SRC　
* The Elements of Programming
** 三大机制

   - 原始的表达式 :: 最简单的实体（元素）
   - 组合的方法 :: 组合简单一级的简单的实体
   - 抽象的方法 :: 能命名实体和调用（操作）实体

*** 编程，需要处理的元素elements ： procedures　和　data

    - date :: 我们想去操作和处理的东西
    - procedures :: 操作和处理date 的规则

** chapter 1
*** 1.1The Elements of Programming

**** 1.1.1 Expressions

*You type an "expression",and the interpreter responds by displaying the result of its "evaluating" that expression.*

***** Number

> 486
486

> 985
985

***** '+' or '*'
***** () 这就是combined的形式，叫combinations

(- 1000 334) 这是一个expression
666

(+ 2.7 10)   这是一个expression
12.7

括号最左边的元素叫 "operator"（函数）,其余的叫"operands"，这种表达方式叫前缀表达式，可以嵌套，例如：

(+ (* 3 5) (- 10 6)) =19   这是三个expression
 |  |       |
  \/        |
operator  operator

**** 1.1.2 Naming and the Environment

***** Naming

We say that the name identifies a "variable" whose "value" is the object.

In the Scheme dialect of Lisp, we *name things with `define'*.  Typing

(define size 2)

***** Environment

  It should be clear that the possibility of associating values with
symbols and later retrieving them means that the interpreter must
maintain some sort of *memory that keeps track of the name-object pairs*.
This memory is *called the "environment"* (more precisely the "global
environment", since we will see later that a computation may involve a
number of different environments)

**** 1.1.3 Evaluating Combinations

***** To evaluate combination(不包括definitions)

1. Evaluate the subexpressions of the combination.

2. Apply the procedure that is the value of the leftmost
subexpression (the operator) to the arguments that are the
values of the other subexpressions (the operands).

例子：
(+ (* 3 5) (- 10 6))
 | \     / \      /
 |  \   /   \    /
 |   \ /     \  /
 |    |       ||
 ①　　②　　　　③
 subexpressions(三个,①，②，③),combination(一个)

在(* 3 5)里，又有三个subexpressions．对这些 subexpressions 求值，这就是规则１．

 ①是 operator，②，③则是 operands，在(* 3 5)里，'*'是 operator，'3'和'5'是 operands，将各个 operands的值应用到 operator，将②，③的值应用到①里，将 3,5 的值应用到 *里，这就是规则２．

In general, we shall see that *recursion is a very powerful technique for dealing with hierarchical(分等级的), treelike objects.* the "percolate values upward" form of the evaluation rule is an example of a general kind of process known as "tree accumulation(积聚)".

***** Evaluate  subexpression consequence (求值各个 subexpressions的结果)

紧接上面一个例子说明

1. the values of numerals are the numbers that they name,
2. the values of built-in operators are the machine instruction
sequences that carry out the corresponding operations, and
3. the values of other names are the objects associated with those
names in the environment.

***** define 不是一个 combination

(define x 3)

one of which is the value of the symbol `x' and the other of which is 3, since the purpose of the `define' is precisely to associate `x' with a value.  (That is, `(define x 3)' is not a combination.)

**** 1.1.4 Compound Procedures

We have identified in Lisp some of the elements that must appear in any
powerful programming language:

   * Numbers and arithmetic operations are primitive data and
     procedures.

   * Nesting of combinations provides a means of combining operations.

   * Definitions that associate names with values provide a limited
     means of abstraction.

***** procedure definitions (定义一个 procedure)

a abstraction technique by which a compound operation can be given a name and then referred to as a unit.

     (define (square x) (* x x))

   We can understand this in the following way:

     (define (square    x)         (*      x         x))
       |        |       |           |      |         |
      To     square  something,  multiply  it  by  itself.

We have here a "compound procedure", which has been given the name
`square'.  The procedure represents the operation of multiplying
something by itself.  The thing to be multiplied is given a *local* name,
`x', which plays the same role that a pronoun plays in natural
language.  Evaluating the definition *creates this compound procedure*
and *associates it with the name `square'*

***** procedure definition form

接着上面的 square 的定义

The general form of a procedure definition is

     (define (<NAME> <FORMAL PARAMETERS>) <BODY>)

**** 1.1.5 The Substitution (代换) Model for Procedure Application

***** normal-order evaluation(正则序求值)

完全展开后求值( 完全－> 求值 operand 的值是 number 或者 built-in operator )
例子：
     (sum-of-squares (+ 5 1) (* 5 2))

     (+    (square (+ 5 1))      (square (* 5 2))  )

     (+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))

     (+         (* 6 6)             (* 10 10))

     (+           36                   100)

                         136

***** applicative-order evaluation (应用序求值), Lisp使用这种方式求值.

先求值 (subexpression)，后应用 (operator)，从右到左．

**** 1.1.6 Conditional Expressions and Predicates

case analysis

1. 'cond'
例子：
(define (abs x)
       (cond ((> x 0) x)
             ((= x 0) 0)
             ((< x 0) (- x))))
2. 'if'
例子：
(define (abs x)
       (if (< x 0)
           (- x)
           x))

3. 谓词类
3.1 'and'，都为真，则真
As an example of how these are used, the condition that a number x
be in the range 5 < x < 10 may be expressed as

     (and (> x 5) (< x 10))

3.2 'or'，其一为真，则真
   As another example, we can define a predicate to test whether one
number is greater than or equal to another as

     (define (>= x y)
       (or (> x y) (= x y)))

3.3 'not'，不符合条件则为真
   As another example, we can define a predicate to test whether one
number is greater than or equal to another as

     (define (>= x y)
       (or (> x y) (= x y)))

**** 1.1.7 Example: Square Roots by Newton's Method
**** 1.1.8 Procedures as Black-Box Abstractions(黑盒抽象)[多花点时间好好看看]

   So a procedure definition should be able to suppress detail.  The
users of the procedure may not have written the procedure themselves,
but may have obtained it from another programmer as a black box.  A
user should not need to know how the procedure is implemented in order
to use it.
我们可以直接使用那个symbol，而不用知道内部实现的细节．

***** Local names

  One detail of a procedure's implementation that should not matter to
the user of the procedure is the implementer's choice of names for the
procedure's formal parameters.  Thus, the following procedures should
not be distinguishable:

     (define (square x) (* x x))

     (define (square y) (* y y))

  This principle--that the meaning of a procedure should be
independent of the parameter names used by its author--seems on the
surface to be self-evident, but its consequences are profound.

关于free bound变量

  A formal parameter of a procedure has a very special role in the
procedure definition, in that it doesn't matter what name the formal
parameter has.  Such a name is called a "bound variable", and we say
that the procedure definition "binds" its formal parameters.  The
meaning of a procedure definition is unchanged if a bound variable is
consistently renamed throughout the definition.(2)  If a variable is
not bound, we say that it is "free".  The set of expressions for which
a binding defines a name is called the "scope" of that name.  In a
procedure definition, the bound variables declared as the formal
parameters of the procedure have the body of the procedure as their
scope.

   In the definition of `good-enough?' above, `guess' and `x' are bound
variables but `<', `-', `abs', and `square' are free.  The meaning of
`good-enough?' should be independent of the names we choose for `guess'
and `x' so long as they are distinct and different from `<', `-',
`abs', and `square'.  (If we renamed `guess' to `abs' we would have
introduced a bug by "capturing" the variable `abs'.  It would have
changed from free to bound.)  The meaning of `good-enough?' is not
independent of the names of its free variables, however.  It surely
depends upon the fact (external to this definition) that the symbol
`abs' names a procedure for computing the absolute value of a number.
`Good-enough?' will compute a different function if we substitute `cos'
for `abs' in its definition.

***** Internal definitions and *block structure*

例子：
#+begin_src scheme
;;其中Ｘ为自由变量，在整个函数里，它的值始终取决于外来传入的值
    (define (sqrt x)
       (define (good-enough? guess)
         (< (abs (- (square guess) x)) 0.001))
       (define (improve guess)
         (average guess (/ x guess)))
       (define (sqrt-iter guess)
         (if (good-enough? guess)
             guess
             (sqrt-iter (improve guess))))
       (sqrt-iter 1.0))
#+end_src

这样可以减少全局变量名的占用

*** 1.2 Procedures and the Processes They Generate

We lack the experience to predict the consequences of making a move (executing a procedure).

*Task*

we can at least try to describe some typical patterns of process evolution.


**** 1.2.1 Linear Recursion and Iteration

线性递归：

          (factorial 6)        ------------------------.
          (* 6 (factorial 5))                          |
          (* 6 (* 5 (factorial 4)))                    |
          (* 6 (* 5 (* 4 (factorial 3))))              |
          (* 6 (* 5 (* 4 (* 3 (factorial 2)))))        |
          (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))  |
          (* 6 (* 5 (* 4 (* 3 (* 2 1)))))              |
          (* 6 (* 5 (* 4 (* 3 2))))                    |
          (* 6 (* 5 (* 4 6)))                          |
          (* 6 (* 5 24))                               |
          (* 6 120)                                    |
          720          <-------------------------------'

思想：将大的问题一步步细化

-------------------------------------------------------------------------

线性迭代(反复的)：
          (factorial 6)   -----.
          (fact-iter   1 1 6)  |
          (fact-iter   1 2 6)  |
          (fact-iter   2 3 6)  |
          (fact-iter   6 4 6)  |
          (fact-iter  24 5 6)  |
          (fact-iter 120 6 6)  |
          (fact-iter 720 7 6)  V
          720

-------------------------------------------------------------------------

**** 1.2.2 Tree Recursion

*思想：将大的问题一步步细化，最终得以解决*

斐波那契数列

              /
              |  0                        if n = 0
     Fib(n) = <  1                        if n = 1
              |  Fib(n - 1) + Fib(n - 2)  otherwise
              \

*Figure 1.5:* The tree-recursive process generated in computing
`(fib 5)'.

                             ..<............ fib5   <..........
                          ...     ___________/  \___________   .
                       ...       /       . .....            \    .
                     ..       fib4     .        . . . .     fib3  .
                   ..     ____/. \____  ..             .  __/  \__  .
                 ..      /  . .  ..   \    .        ..   /  . .   \   .
               ..     fib3 .       .  fib2 .        . fib2 .   .  fib1 .
             ..      / . \  .     .   /  \  .      .  /  \ ...  .  |  .
           ..       / . . \   .  .   /  . \   .  .   / .  \   .  . 1 .
          .      fib2 . . fib1.  .fib1 .  fib0 . .fib1. . fib0 .  .  .
          .      /  \  . . |  .  . |  .  . |   . . |   . . |   .   .>
          V     /  . \   . 1  .  . 1  .  . 0  .  . 1  .  . 0  ..
          .  fib1 .. fib0..  .   .   .   .   .   V   .   ..  .
          .   |  .  . |  . .>     .>.     . .    ..>.      .>
          .   1 .   . 0  .
           .   .     .  .
            .>.       ..


*Example: Counting change*

     (define (count-change amount)
       (cc amount 5))

     (define (cc amount kinds-of-coins)
       (cond ((= amount 0) 1)
             ((or (< amount 0) (= kinds-of-coins 0)) 0)
             (else (+ (cc amount
                          (- kinds-of-coins 1))
                      (cc (- amount
                             (first-denomination kinds-of-coins))
                          kinds-of-coins)))))

     (define (first-denomination kinds-of-coins)
       (cond ((= kinds-of-coins 1) 1)
             ((= kinds-of-coins 2) 5)
             ((= kinds-of-coins 3) 10)
             ((= kinds-of-coins 4) 25)
             ((= kinds-of-coins 5) 50)))

**** 1.2.3 Orders of Growth
**** 1.2.4 Exponentiation (求幂)

这一节，通过一些手段降低算法的 orders of growth

#+begin_src scheme
  (define (expt b n)
     (if (= n 0)
         1
        (* b (expt b (- n 1)))))
#+end_src

#+begin_src scheme
  (define (expt-fast b n)
    (cond ((even? n) (square (expt-fast b (/ n 2))))
          (else (* b (expt-fast b (- n 1))))))
#+end_src

#+begin_src scheme
  (define (expt-line b n)
    (define (expt-item product count)
          ))
#+end_src

**** 1.2.5 Greatest Common Divisors(最大公约数)

Euclid's Algorithm

#+begin_src scheme
  (define (gcd-* a b)
    (if (= b 0)
        a
        (gcd-* b (remainder a b))))

#+end_src

**** 1.2.6 Example: Testing for Primality

*** 1.3 Formulating Abstractions with Higher-Order Procedures

One of the things we should demand from a powerful programming language is the ability to build abstractions by assigning names to common patterns and then to work in terms of the abstractions directly.  Procedures provide this ability.  This is why all but the most primitive programming languages include mechanisms(机制) for defining procedures.

Yet even in numerical processing we will be severely limited in our ability to create abstractions if we are restricted to procedures whose parameters must be numbers.  Often the same programming pattern will be used with a number of different procedures.  To express such patterns as concepts, we will need to construct procedures that can accept procedures as arguments or return procedures as values.  Procedures that manipulate procedures are called *"higher-order procedures"*.  This section shows how higher-order procedures can serve as powerful abstraction mechanisms, vastly increasing the expressive power of our language.

从中抽出一种公共的 pattern (模式)

**** 1.3.1 Procedures as Arguments

1) 初步见识的抽象的力量
2) 一个 procedure 过程作为一个参数传入给函数

最好看看原文
+-----------------------------------------------+
|                                               |
|  (define (sum term a next b)                  |
|    (if (> a b)                                |
|        0                                      |
|        (+ (term a)                            |
|           (sum term (next a) next b))))       |
|                                               |
+-----------------------------------------------+
                         |
                         |
                         |  更加抽象的统计函数(可以根据情况改变统计的方式,例如把 + 换成 -,*,/)
                         |
                         |
                        \ /
                         '
+---------------------------------------------------------------------------------+
|                                                                                 |
|  (define (accumulate combiner null-value term a next b)                         |
|    (if (> a b)                                                                  |
|        null-value                                                               |
|        (combiner (term a)                                                       |
|                  (accumulate combiner null-value term (next a) next b))))       |
|                                                                                 |
+---------------------------------------------------------------------------------+



(define (inc n)
  (+ 1 n))

(define (sum-cubes a b)
  (sum cube a inc b))

**** 1.3.2 Constructing Procedures Using `Lambda'

1.  (define plus4 (lambda (x) (+ x 4)))           'Lambda'里没有实参.
2.  ((lambda (x y z) (+ x y (square z))) 1 2 3)   'Lambda'里有实参.

第一个过程可以使用的方法(共有三种,第二种用起来更原生，接近本质)

+-------------------------------------------------+
|1.use define                                     |
|                                                 |
|    (define (f x y)                              |
|      (define (f-helper a b)                     |
|        (+ (* x (square a))                      |
|           (* y b)                               |
|           (* a b)))                             |
|      (f-helper (+ 1 (* x y))                    |
|                (- 1 y)))                        |
+-------------------------------------------------+






+--------------------------------------------------------+
|2.use lambda                                            |
|                                                        |
|    (define (f x y)                                     |
|      ((lambda (a b)                                    |
|         (+ (* x (square a))                            |
|            (* y b)                                     |
|            (* a b)))                                   |
|       (+ 1 (* x y))                                    |
|       (- 1 y)))                                        |
+--------------------------------------------------------+






+---------------------------------------------------------------+
|3.use let                                                      |
|                                                               |
|    (define (f x y)                                            |
|      (let ((a (+ 1 (* x y)))                                  |
|            (b (- 1 y)))                                       |
|        (+ (* x (square a))                                    |
|           (* y b)                                             |
|           (* a b))))                                          |
+---------------------------------------------------------------+

***** Using `let' to create local variables

本质:  A `let' expression is simply syntactic sugar for the underlying `lambda' application.

*提醒 1*   `Let' allows one to bind variables as locally as possible to where
      they are to be used.  For example, if the value of `x' is 5, the
      value of the expression

#+begin_src scheme
  (+ (let ((x 3))
       (+ x (* x 10)))
     x)
  ;;   .
  ;;  /|\
  ;;   |
  ;;   ----------------.
  ;; ---> 38           |
  ;; 整个 let 表达式里的 x 与这个是两个不同的值,这个 x 的值取决于当下的环境
#+end_src

     is 38.  Here, the `x' in the body of the `let' is 3, so the value
     of the `let' expression is 33.  On the other hand, the `x' that is
     the second argument to the outermost `+' is still 5. 书上的解释.

*提醒 2*   The variables' values are computed outside the `let'.  This
     matters when the expressions that provide the values for the local
     variables depend upon variables having the same names as the local
     variables themselves.  For example, if the value of `x' is 2, the
     expression

   _变量的值是在 let 之外求值的．_

#+begin_src scheme
       (let ((x 3)
             (y (+ x 2)))
         (* x y))

#+end_src

     will have the value 12 because, inside the body of the `let', `x'
     will be 3 and `y' will be 4 (which is the outer `x' plus 2).

**** 1.3.3 Procedures as General Methods

   In this section we discuss two more elaborate examples--general methods for finding zeros and
fixed points of functions--and show how these methods can be expressed directly as procedures.


*1. Finding roots of equations by the half-interval method*
#+begin_src scheme
  (define (search f neg-point pos-point)
    (let ((midpoint (average neg-point pos-point)))
      (if (close-enough? neg-point pos-point)
          midpoint
          (let ((test-value (f midpoint)))
            (cond ((positive? test-value)
                   (search f neg-point midpoint))
                  ((negative? test-value)
                   (search f midpoint pos-point))
                  (else midpoint))))))

  (define (close-enough? x y)
    (< (abs (- x y)) 0.001))

  (define (half-interval-method f a b)
    (let ((a-value (f a))
          (b-value (f b)))
      (cond ((and (negative? a-value) (positive? b-value))
             (search f a b))
            ((and (negative? b-value) (positive? a-value))
             (search f b a))
            (else
             (error "Values are not of opposite sign" a b)))))
#+end_src



*2. Finding fixed points of functions*
#+begin_src scheme
  (define tolerance 0.00001)

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))

#+end_src
***** function
****** special form

1) define
2) begin

The expressions are evaluated sequentially from left to right, and the value of the last expression is returned. This expression type is used to sequence side effects such as input and output.

**** 1.3.4 Procedures as Returned Values

 #+BEGIN_SRC scheme
   (define (average x y)
     (/ (+ x y) 2))
   ;;接下来的这个函数返回了一个procedures,仔细看两者的形参,是不同的
   (define (average-damp f)
     (lambda (x) (average x (f x))))
   ;;求平方根
   (define (sqrt x)
     (fixed-point (average-damp (lambda (y) (/ x y)))
   ;;求立方根
   (define (cube-root x)
     (fixed-point (average-damp (lambda (y) (/ x (square y))))
                  1.0))
   1.0))

   ;;同下式比较
   (define (sqrt-iter guess x)
     (if (good-enough? guess x)
         guess
         (sqrt-iter (improve guess x)
                    x)))

   (define (improve guess x)
     (average guess (/ x guess)))

   (define (good-enough? guess x)
     (< (abs (- (square guess) x)) 0.001))

 #+END_SRC

***** Newton's method

             g(x + dx) - g(x)
     Dg(c) = ----------------
                    dx

Thus, we can express the idea of derivative (taking dx to be, say,
0.00001) as the procedure
#+BEGIN_SRC scheme
  (define (deriv g)
    (lambda (x)
      (/ (- (g (+ x dx)) (g x))
         dx)))

  (define dx 0.00001)

  (define (newton-transform g)
    (lambda (x)
      (- x (/ (g x) ((deriv g) x)))))

  (define (newtons-method g guess)
    (fixed-point (newton-transform g) guess))
#+END_SRC
** chapter 2
*** 2.1 Introduction to Data Abstraction
**** 2.1.1 Example: Arithmetic Operations for Rational Numbers

We are using here a powerful strategy of synthesis: *"wishful thinking"*.


#+BEGIN_SRC scheme
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))

  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))

  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))

  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))

  (define (equal-rat? x y)
    (= (* (numer x) (denom y))
       (* (numer y) (denom x))))
#+END_SRC

Pairs
通过序对，m可以定义上面我们需要用到的函数(make-rat numer and denom)
#+BEGIN_SRC scheme
  (define (make-rat n d) (cons n d))

  (define (numer x) (car x))

  (define (denom x) (cdr x))
#+END_SRC
